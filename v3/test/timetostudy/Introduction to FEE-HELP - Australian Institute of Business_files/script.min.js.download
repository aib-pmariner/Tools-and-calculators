/*!
 * PROJECT
 * Marketing.Website Frontend Project
 * @version 1.0.0
 * @created 2017/07/05
 * ** This file was compiled with Grunt. Please do not edit it directly. **
 */
/*
 * jQuery FlexSlider v2.6.3
 * Copyright 2012 WooThemes
 * Contributing Author: Tyler Smith
 */
(function($) {
    var focused = true;
    //FlexSlider: Object Instance
    $.flexslider = function(el, options) {
        var slider = $(el);
        // making variables public
        slider.vars = $.extend({}, $.flexslider.defaults, options);
        var namespace = slider.vars.namespace, msGesture = window.navigator && window.navigator.msPointerEnabled && window.MSGesture, touch = ("ontouchstart" in window || msGesture || window.DocumentTouch && document instanceof DocumentTouch) && slider.vars.touch, // depricating this idea, as devices are being released with both of these events
        eventType = "click touchend MSPointerUp keyup", watchedEvent = "", watchedEventClearTimer, vertical = slider.vars.direction === "vertical", reverse = slider.vars.reverse, carousel = slider.vars.itemWidth > 0, fade = slider.vars.animation === "fade", asNav = slider.vars.asNavFor !== "", methods = {};
        // Store a reference to the slider object
        $.data(el, "flexslider", slider);
        // Private slider methods
        methods = {
            init: function() {
                slider.animating = false;
                // Get current slide and make sure it is a number
                slider.currentSlide = parseInt(slider.vars.startAt ? slider.vars.startAt : 0, 10);
                if (isNaN(slider.currentSlide)) {
                    slider.currentSlide = 0;
                }
                slider.animatingTo = slider.currentSlide;
                slider.atEnd = slider.currentSlide === 0 || slider.currentSlide === slider.last;
                slider.containerSelector = slider.vars.selector.substr(0, slider.vars.selector.search(" "));
                slider.slides = $(slider.vars.selector, slider);
                slider.container = $(slider.containerSelector, slider);
                slider.count = slider.slides.length;
                // SYNC:
                slider.syncExists = $(slider.vars.sync).length > 0;
                // SLIDE:
                if (slider.vars.animation === "slide") {
                    slider.vars.animation = "swing";
                }
                slider.prop = vertical ? "top" : "marginLeft";
                slider.args = {};
                // SLIDESHOW:
                slider.manualPause = false;
                slider.stopped = false;
                //PAUSE WHEN INVISIBLE
                slider.started = false;
                slider.startTimeout = null;
                // TOUCH/USECSS:
                slider.transitions = !slider.vars.video && !fade && slider.vars.useCSS && function() {
                    var obj = document.createElement("div"), props = [ "perspectiveProperty", "WebkitPerspective", "MozPerspective", "OPerspective", "msPerspective" ];
                    for (var i in props) {
                        if (obj.style[props[i]] !== undefined) {
                            slider.pfx = props[i].replace("Perspective", "").toLowerCase();
                            slider.prop = "-" + slider.pfx + "-transform";
                            return true;
                        }
                    }
                    return false;
                }();
                slider.ensureAnimationEnd = "";
                // CONTROLSCONTAINER:
                if (slider.vars.controlsContainer !== "") slider.controlsContainer = $(slider.vars.controlsContainer).length > 0 && $(slider.vars.controlsContainer);
                // MANUAL:
                if (slider.vars.manualControls !== "") slider.manualControls = $(slider.vars.manualControls).length > 0 && $(slider.vars.manualControls);
                // CUSTOM DIRECTION NAV:
                if (slider.vars.customDirectionNav !== "") slider.customDirectionNav = $(slider.vars.customDirectionNav).length === 2 && $(slider.vars.customDirectionNav);
                // RANDOMIZE:
                if (slider.vars.randomize) {
                    slider.slides.sort(function() {
                        return Math.round(Math.random()) - .5;
                    });
                    slider.container.empty().append(slider.slides);
                }
                slider.doMath();
                // INIT
                slider.setup("init");
                // CONTROLNAV:
                if (slider.vars.controlNav) {
                    methods.controlNav.setup();
                }
                // DIRECTIONNAV:
                if (slider.vars.directionNav) {
                    methods.directionNav.setup();
                }
                // KEYBOARD:
                if (slider.vars.keyboard && ($(slider.containerSelector).length === 1 || slider.vars.multipleKeyboard)) {
                    $(document).bind("keyup", function(event) {
                        var keycode = event.keyCode;
                        if (!slider.animating && (keycode === 39 || keycode === 37)) {
                            var target = keycode === 39 ? slider.getTarget("next") : keycode === 37 ? slider.getTarget("prev") : false;
                            slider.flexAnimate(target, slider.vars.pauseOnAction);
                        }
                    });
                }
                // MOUSEWHEEL:
                if (slider.vars.mousewheel) {
                    slider.bind("mousewheel", function(event, delta, deltaX, deltaY) {
                        event.preventDefault();
                        var target = delta < 0 ? slider.getTarget("next") : slider.getTarget("prev");
                        slider.flexAnimate(target, slider.vars.pauseOnAction);
                    });
                }
                // PAUSEPLAY
                if (slider.vars.pausePlay) {
                    methods.pausePlay.setup();
                }
                //PAUSE WHEN INVISIBLE
                if (slider.vars.slideshow && slider.vars.pauseInvisible) {
                    methods.pauseInvisible.init();
                }
                // SLIDSESHOW
                if (slider.vars.slideshow) {
                    if (slider.vars.pauseOnHover) {
                        slider.hover(function() {
                            if (!slider.manualPlay && !slider.manualPause) {
                                slider.pause();
                            }
                        }, function() {
                            if (!slider.manualPause && !slider.manualPlay && !slider.stopped) {
                                slider.play();
                            }
                        });
                    }
                    // initialize animation
                    //If we're visible, or we don't use PageVisibility API
                    if (!slider.vars.pauseInvisible || !methods.pauseInvisible.isHidden()) {
                        slider.vars.initDelay > 0 ? slider.startTimeout = setTimeout(slider.play, slider.vars.initDelay) : slider.play();
                    }
                }
                // ASNAV:
                if (asNav) {
                    methods.asNav.setup();
                }
                // TOUCH
                if (touch && slider.vars.touch) {
                    methods.touch();
                }
                // FADE&&SMOOTHHEIGHT || SLIDE:
                if (!fade || fade && slider.vars.smoothHeight) {
                    $(window).bind("resize orientationchange focus", methods.resize);
                }
                slider.find("img").attr("draggable", "false");
                // API: start() Callback
                setTimeout(function() {
                    slider.vars.start(slider);
                }, 200);
            },
            asNav: {
                setup: function() {
                    slider.asNav = true;
                    slider.animatingTo = Math.floor(slider.currentSlide / slider.move);
                    slider.currentItem = slider.currentSlide;
                    slider.slides.removeClass(namespace + "active-slide").eq(slider.currentItem).addClass(namespace + "active-slide");
                    if (!msGesture) {
                        slider.slides.on(eventType, function(e) {
                            e.preventDefault();
                            var $slide = $(this), target = $slide.index();
                            var posFromLeft = $slide.offset().left - $(slider).scrollLeft();
                            // Find position of slide relative to left of slider container
                            if (posFromLeft <= 0 && $slide.hasClass(namespace + "active-slide")) {
                                slider.flexAnimate(slider.getTarget("prev"), true);
                            } else if (!$(slider.vars.asNavFor).data("flexslider").animating && !$slide.hasClass(namespace + "active-slide")) {
                                slider.direction = slider.currentItem < target ? "next" : "prev";
                                slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                            }
                        });
                    } else {
                        el._slider = slider;
                        slider.slides.each(function() {
                            var that = this;
                            that._gesture = new MSGesture();
                            that._gesture.target = that;
                            that.addEventListener("MSPointerDown", function(e) {
                                e.preventDefault();
                                if (e.currentTarget._gesture) {
                                    e.currentTarget._gesture.addPointer(e.pointerId);
                                }
                            }, false);
                            that.addEventListener("MSGestureTap", function(e) {
                                e.preventDefault();
                                var $slide = $(this), target = $slide.index();
                                if (!$(slider.vars.asNavFor).data("flexslider").animating && !$slide.hasClass("active")) {
                                    slider.direction = slider.currentItem < target ? "next" : "prev";
                                    slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                                }
                            });
                        });
                    }
                }
            },
            controlNav: {
                setup: function() {
                    if (!slider.manualControls) {
                        methods.controlNav.setupPaging();
                    } else {
                        // MANUALCONTROLS:
                        methods.controlNav.setupManual();
                    }
                },
                setupPaging: function() {
                    var type = slider.vars.controlNav === "thumbnails" ? "control-thumbs" : "control-paging", j = 1, item, slide;
                    slider.controlNavScaffold = $('<ol class="' + namespace + "control-nav " + namespace + type + '"></ol>');
                    if (slider.pagingCount > 1) {
                        for (var i = 0; i < slider.pagingCount; i++) {
                            slide = slider.slides.eq(i);
                            if (undefined === slide.attr("data-thumb-alt")) {
                                slide.attr("data-thumb-alt", "");
                            }
                            var altText = "" !== slide.attr("data-thumb-alt") ? altText = ' alt="' + slide.attr("data-thumb-alt") + '"' : "";
                            item = slider.vars.controlNav === "thumbnails" ? '<img src="' + slide.attr("data-thumb") + '"' + altText + "/>" : '<a href="#">' + j + "</a>";
                            if ("thumbnails" === slider.vars.controlNav && true === slider.vars.thumbCaptions) {
                                var captn = slide.attr("data-thumbcaption");
                                if ("" !== captn && undefined !== captn) {
                                    item += '<span class="' + namespace + 'caption">' + captn + "</span>";
                                }
                            }
                            slider.controlNavScaffold.append("<li>" + item + "</li>");
                            j++;
                        }
                    }
                    // CONTROLSCONTAINER:
                    slider.controlsContainer ? $(slider.controlsContainer).append(slider.controlNavScaffold) : slider.append(slider.controlNavScaffold);
                    methods.controlNav.set();
                    methods.controlNav.active();
                    slider.controlNavScaffold.delegate("a, img", eventType, function(event) {
                        event.preventDefault();
                        if (watchedEvent === "" || watchedEvent === event.type) {
                            var $this = $(this), target = slider.controlNav.index($this);
                            if (!$this.hasClass(namespace + "active")) {
                                slider.direction = target > slider.currentSlide ? "next" : "prev";
                                slider.flexAnimate(target, slider.vars.pauseOnAction);
                            }
                        }
                        // setup flags to prevent event duplication
                        if (watchedEvent === "") {
                            watchedEvent = event.type;
                        }
                        methods.setToClearWatchedEvent();
                    });
                },
                setupManual: function() {
                    slider.controlNav = slider.manualControls;
                    methods.controlNav.active();
                    slider.controlNav.bind(eventType, function(event) {
                        event.preventDefault();
                        if (watchedEvent === "" || watchedEvent === event.type) {
                            var $this = $(this), target = slider.controlNav.index($this);
                            if (!$this.hasClass(namespace + "active")) {
                                target > slider.currentSlide ? slider.direction = "next" : slider.direction = "prev";
                                slider.flexAnimate(target, slider.vars.pauseOnAction);
                            }
                        }
                        // setup flags to prevent event duplication
                        if (watchedEvent === "") {
                            watchedEvent = event.type;
                        }
                        methods.setToClearWatchedEvent();
                    });
                },
                set: function() {
                    var selector = slider.vars.controlNav === "thumbnails" ? "img" : "a";
                    slider.controlNav = $("." + namespace + "control-nav li " + selector, slider.controlsContainer ? slider.controlsContainer : slider);
                },
                active: function() {
                    slider.controlNav.removeClass(namespace + "active").eq(slider.animatingTo).addClass(namespace + "active");
                },
                update: function(action, pos) {
                    if (slider.pagingCount > 1 && action === "add") {
                        slider.controlNavScaffold.append($('<li><a href="#">' + slider.count + "</a></li>"));
                    } else if (slider.pagingCount === 1) {
                        slider.controlNavScaffold.find("li").remove();
                    } else {
                        slider.controlNav.eq(pos).closest("li").remove();
                    }
                    methods.controlNav.set();
                    slider.pagingCount > 1 && slider.pagingCount !== slider.controlNav.length ? slider.update(pos, action) : methods.controlNav.active();
                }
            },
            directionNav: {
                setup: function() {
                    var directionNavScaffold = $('<ul class="' + namespace + 'direction-nav"><li class="' + namespace + 'nav-prev"><a class="' + namespace + 'prev" href="#">' + slider.vars.prevText + '</a></li><li class="' + namespace + 'nav-next"><a class="' + namespace + 'next" href="#">' + slider.vars.nextText + "</a></li></ul>");
                    // CUSTOM DIRECTION NAV:
                    if (slider.customDirectionNav) {
                        slider.directionNav = slider.customDirectionNav;
                    } else if (slider.controlsContainer) {
                        $(slider.controlsContainer).append(directionNavScaffold);
                        slider.directionNav = $("." + namespace + "direction-nav li a", slider.controlsContainer);
                    } else {
                        slider.append(directionNavScaffold);
                        slider.directionNav = $("." + namespace + "direction-nav li a", slider);
                    }
                    methods.directionNav.update();
                    slider.directionNav.bind(eventType, function(event) {
                        event.preventDefault();
                        var target;
                        if (watchedEvent === "" || watchedEvent === event.type) {
                            target = $(this).hasClass(namespace + "next") ? slider.getTarget("next") : slider.getTarget("prev");
                            slider.flexAnimate(target, slider.vars.pauseOnAction);
                        }
                        // setup flags to prevent event duplication
                        if (watchedEvent === "") {
                            watchedEvent = event.type;
                        }
                        methods.setToClearWatchedEvent();
                    });
                },
                update: function() {
                    var disabledClass = namespace + "disabled";
                    if (slider.pagingCount === 1) {
                        slider.directionNav.addClass(disabledClass).attr("tabindex", "-1");
                    } else if (!slider.vars.animationLoop) {
                        if (slider.animatingTo === 0) {
                            slider.directionNav.removeClass(disabledClass).filter("." + namespace + "prev").addClass(disabledClass).attr("tabindex", "-1");
                        } else if (slider.animatingTo === slider.last) {
                            slider.directionNav.removeClass(disabledClass).filter("." + namespace + "next").addClass(disabledClass).attr("tabindex", "-1");
                        } else {
                            slider.directionNav.removeClass(disabledClass).removeAttr("tabindex");
                        }
                    } else {
                        slider.directionNav.removeClass(disabledClass).removeAttr("tabindex");
                    }
                }
            },
            pausePlay: {
                setup: function() {
                    var pausePlayScaffold = $('<div class="' + namespace + 'pauseplay"><a href="#"></a></div>');
                    // CONTROLSCONTAINER:
                    if (slider.controlsContainer) {
                        slider.controlsContainer.append(pausePlayScaffold);
                        slider.pausePlay = $("." + namespace + "pauseplay a", slider.controlsContainer);
                    } else {
                        slider.append(pausePlayScaffold);
                        slider.pausePlay = $("." + namespace + "pauseplay a", slider);
                    }
                    methods.pausePlay.update(slider.vars.slideshow ? namespace + "pause" : namespace + "play");
                    slider.pausePlay.bind(eventType, function(event) {
                        event.preventDefault();
                        if (watchedEvent === "" || watchedEvent === event.type) {
                            if ($(this).hasClass(namespace + "pause")) {
                                slider.manualPause = true;
                                slider.manualPlay = false;
                                slider.pause();
                            } else {
                                slider.manualPause = false;
                                slider.manualPlay = true;
                                slider.play();
                            }
                        }
                        // setup flags to prevent event duplication
                        if (watchedEvent === "") {
                            watchedEvent = event.type;
                        }
                        methods.setToClearWatchedEvent();
                    });
                },
                update: function(state) {
                    state === "play" ? slider.pausePlay.removeClass(namespace + "pause").addClass(namespace + "play").html(slider.vars.playText) : slider.pausePlay.removeClass(namespace + "play").addClass(namespace + "pause").html(slider.vars.pauseText);
                }
            },
            touch: function() {
                var startX, startY, offset, cwidth, dx, startT, onTouchStart, onTouchMove, onTouchEnd, scrolling = false, localX = 0, localY = 0, accDx = 0;
                if (!msGesture) {
                    onTouchStart = function(e) {
                        if (slider.animating) {
                            e.preventDefault();
                        } else if (window.navigator.msPointerEnabled || e.touches.length === 1) {
                            slider.pause();
                            // CAROUSEL:
                            cwidth = vertical ? slider.h : slider.w;
                            startT = Number(new Date());
                            // CAROUSEL:
                            // Local vars for X and Y points.
                            localX = e.touches[0].pageX;
                            localY = e.touches[0].pageY;
                            offset = carousel && reverse && slider.animatingTo === slider.last ? 0 : carousel && reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : carousel && slider.currentSlide === slider.last ? slider.limit : carousel ? (slider.itemW + slider.vars.itemMargin) * slider.move * slider.currentSlide : reverse ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
                            startX = vertical ? localY : localX;
                            startY = vertical ? localX : localY;
                            el.addEventListener("touchmove", onTouchMove, false);
                            el.addEventListener("touchend", onTouchEnd, false);
                        }
                    };
                    onTouchMove = function(e) {
                        // Local vars for X and Y points.
                        localX = e.touches[0].pageX;
                        localY = e.touches[0].pageY;
                        dx = vertical ? startX - localY : startX - localX;
                        scrolling = vertical ? Math.abs(dx) < Math.abs(localX - startY) : Math.abs(dx) < Math.abs(localY - startY);
                        var fxms = 500;
                        if (!scrolling || Number(new Date()) - startT > fxms) {
                            e.preventDefault();
                            if (!fade && slider.transitions) {
                                if (!slider.vars.animationLoop) {
                                    dx = dx / (slider.currentSlide === 0 && dx < 0 || slider.currentSlide === slider.last && dx > 0 ? Math.abs(dx) / cwidth + 2 : 1);
                                }
                                slider.setProps(offset + dx, "setTouch");
                            }
                        }
                    };
                    onTouchEnd = function(e) {
                        // finish the touch by undoing the touch session
                        el.removeEventListener("touchmove", onTouchMove, false);
                        if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
                            var updateDx = reverse ? -dx : dx, target = updateDx > 0 ? slider.getTarget("next") : slider.getTarget("prev");
                            if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {
                                slider.flexAnimate(target, slider.vars.pauseOnAction);
                            } else {
                                if (!fade) {
                                    slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                                }
                            }
                        }
                        el.removeEventListener("touchend", onTouchEnd, false);
                        startX = null;
                        startY = null;
                        dx = null;
                        offset = null;
                    };
                    el.addEventListener("touchstart", onTouchStart, false);
                } else {
                    el.style.msTouchAction = "none";
                    el._gesture = new MSGesture();
                    el._gesture.target = el;
                    el.addEventListener("MSPointerDown", onMSPointerDown, false);
                    el._slider = slider;
                    el.addEventListener("MSGestureChange", onMSGestureChange, false);
                    el.addEventListener("MSGestureEnd", onMSGestureEnd, false);
                    function onMSPointerDown(e) {
                        e.stopPropagation();
                        if (slider.animating) {
                            e.preventDefault();
                        } else {
                            slider.pause();
                            el._gesture.addPointer(e.pointerId);
                            accDx = 0;
                            cwidth = vertical ? slider.h : slider.w;
                            startT = Number(new Date());
                            // CAROUSEL:
                            offset = carousel && reverse && slider.animatingTo === slider.last ? 0 : carousel && reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : carousel && slider.currentSlide === slider.last ? slider.limit : carousel ? (slider.itemW + slider.vars.itemMargin) * slider.move * slider.currentSlide : reverse ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
                        }
                    }
                    function onMSGestureChange(e) {
                        e.stopPropagation();
                        var slider = e.target._slider;
                        if (!slider) {
                            return;
                        }
                        var transX = -e.translationX, transY = -e.translationY;
                        //Accumulate translations.
                        accDx = accDx + (vertical ? transY : transX);
                        dx = accDx;
                        scrolling = vertical ? Math.abs(accDx) < Math.abs(-transX) : Math.abs(accDx) < Math.abs(-transY);
                        if (e.detail === e.MSGESTURE_FLAG_INERTIA) {
                            setImmediate(function() {
                                el._gesture.stop();
                            });
                            return;
                        }
                        if (!scrolling || Number(new Date()) - startT > 500) {
                            e.preventDefault();
                            if (!fade && slider.transitions) {
                                if (!slider.vars.animationLoop) {
                                    dx = accDx / (slider.currentSlide === 0 && accDx < 0 || slider.currentSlide === slider.last && accDx > 0 ? Math.abs(accDx) / cwidth + 2 : 1);
                                }
                                slider.setProps(offset + dx, "setTouch");
                            }
                        }
                    }
                    function onMSGestureEnd(e) {
                        e.stopPropagation();
                        var slider = e.target._slider;
                        if (!slider) {
                            return;
                        }
                        if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
                            var updateDx = reverse ? -dx : dx, target = updateDx > 0 ? slider.getTarget("next") : slider.getTarget("prev");
                            if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {
                                slider.flexAnimate(target, slider.vars.pauseOnAction);
                            } else {
                                if (!fade) {
                                    slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                                }
                            }
                        }
                        startX = null;
                        startY = null;
                        dx = null;
                        offset = null;
                        accDx = 0;
                    }
                }
            },
            resize: function() {
                if (!slider.animating && slider.is(":visible")) {
                    if (!carousel) {
                        slider.doMath();
                    }
                    if (fade) {
                        // SMOOTH HEIGHT:
                        methods.smoothHeight();
                    } else if (carousel) {
                        //CAROUSEL:
                        slider.slides.width(slider.computedW);
                        slider.update(slider.pagingCount);
                        slider.setProps();
                    } else if (vertical) {
                        //VERTICAL:
                        slider.viewport.height(slider.h);
                        slider.setProps(slider.h, "setTotal");
                    } else {
                        // SMOOTH HEIGHT:
                        if (slider.vars.smoothHeight) {
                            methods.smoothHeight();
                        }
                        slider.newSlides.width(slider.computedW);
                        slider.setProps(slider.computedW, "setTotal");
                    }
                }
            },
            smoothHeight: function(dur) {
                if (!vertical || fade) {
                    var $obj = fade ? slider : slider.viewport;
                    dur ? $obj.animate({
                        height: slider.slides.eq(slider.animatingTo).innerHeight()
                    }, dur) : $obj.innerHeight(slider.slides.eq(slider.animatingTo).innerHeight());
                }
            },
            sync: function(action) {
                var $obj = $(slider.vars.sync).data("flexslider"), target = slider.animatingTo;
                switch (action) {
                  case "animate":
                    $obj.flexAnimate(target, slider.vars.pauseOnAction, false, true);
                    break;

                  case "play":
                    if (!$obj.playing && !$obj.asNav) {
                        $obj.play();
                    }
                    break;

                  case "pause":
                    $obj.pause();
                    break;
                }
            },
            uniqueID: function($clone) {
                // Append _clone to current level and children elements with id attributes
                $clone.filter("[id]").add($clone.find("[id]")).each(function() {
                    var $this = $(this);
                    $this.attr("id", $this.attr("id") + "_clone");
                });
                return $clone;
            },
            pauseInvisible: {
                visProp: null,
                init: function() {
                    var visProp = methods.pauseInvisible.getHiddenProp();
                    if (visProp) {
                        var evtname = visProp.replace(/[H|h]idden/, "") + "visibilitychange";
                        document.addEventListener(evtname, function() {
                            if (methods.pauseInvisible.isHidden()) {
                                if (slider.startTimeout) {
                                    clearTimeout(slider.startTimeout);
                                } else {
                                    slider.pause();
                                }
                            } else {
                                if (slider.started) {
                                    slider.play();
                                } else {
                                    if (slider.vars.initDelay > 0) {
                                        setTimeout(slider.play, slider.vars.initDelay);
                                    } else {
                                        slider.play();
                                    }
                                }
                            }
                        });
                    }
                },
                isHidden: function() {
                    var prop = methods.pauseInvisible.getHiddenProp();
                    if (!prop) {
                        return false;
                    }
                    return document[prop];
                },
                getHiddenProp: function() {
                    var prefixes = [ "webkit", "moz", "ms", "o" ];
                    // if 'hidden' is natively supported just return it
                    if ("hidden" in document) {
                        return "hidden";
                    }
                    // otherwise loop over all the known prefixes until we find one
                    for (var i = 0; i < prefixes.length; i++) {
                        if (prefixes[i] + "Hidden" in document) {
                            return prefixes[i] + "Hidden";
                        }
                    }
                    // otherwise it's not supported
                    return null;
                }
            },
            setToClearWatchedEvent: function() {
                clearTimeout(watchedEventClearTimer);
                watchedEventClearTimer = setTimeout(function() {
                    watchedEvent = "";
                }, 3e3);
            }
        };
        // public methods
        slider.flexAnimate = function(target, pause, override, withSync, fromNav) {
            if (!slider.vars.animationLoop && target !== slider.currentSlide) {
                slider.direction = target > slider.currentSlide ? "next" : "prev";
            }
            if (asNav && slider.pagingCount === 1) slider.direction = slider.currentItem < target ? "next" : "prev";
            if (!slider.animating && (slider.canAdvance(target, fromNav) || override) && slider.is(":visible")) {
                if (asNav && withSync) {
                    var master = $(slider.vars.asNavFor).data("flexslider");
                    slider.atEnd = target === 0 || target === slider.count - 1;
                    master.flexAnimate(target, true, false, true, fromNav);
                    slider.direction = slider.currentItem < target ? "next" : "prev";
                    master.direction = slider.direction;
                    if (Math.ceil((target + 1) / slider.visible) - 1 !== slider.currentSlide && target !== 0) {
                        slider.currentItem = target;
                        slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
                        target = Math.floor(target / slider.visible);
                    } else {
                        slider.currentItem = target;
                        slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
                        return false;
                    }
                }
                slider.animating = true;
                slider.animatingTo = target;
                // SLIDESHOW:
                if (pause) {
                    slider.pause();
                }
                // API: before() animation Callback
                slider.vars.before(slider);
                // SYNC:
                if (slider.syncExists && !fromNav) {
                    methods.sync("animate");
                }
                // CONTROLNAV
                if (slider.vars.controlNav) {
                    methods.controlNav.active();
                }
                // !CAROUSEL:
                // CANDIDATE: slide active class (for add/remove slide)
                if (!carousel) {
                    slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
                }
                // INFINITE LOOP:
                // CANDIDATE: atEnd
                slider.atEnd = target === 0 || target === slider.last;
                // DIRECTIONNAV:
                if (slider.vars.directionNav) {
                    methods.directionNav.update();
                }
                if (target === slider.last) {
                    // API: end() of cycle Callback
                    slider.vars.end(slider);
                    // SLIDESHOW && !INFINITE LOOP:
                    if (!slider.vars.animationLoop) {
                        slider.pause();
                    }
                }
                // SLIDE:
                if (!fade) {
                    var dimension = vertical ? slider.slides.filter(":first").height() : slider.computedW, margin, slideString, calcNext;
                    // INFINITE LOOP / REVERSE:
                    if (carousel) {
                        margin = slider.vars.itemMargin;
                        calcNext = (slider.itemW + margin) * slider.move * slider.animatingTo;
                        slideString = calcNext > slider.limit && slider.visible !== 1 ? slider.limit : calcNext;
                    } else if (slider.currentSlide === 0 && target === slider.count - 1 && slider.vars.animationLoop && slider.direction !== "next") {
                        slideString = reverse ? (slider.count + slider.cloneOffset) * dimension : 0;
                    } else if (slider.currentSlide === slider.last && target === 0 && slider.vars.animationLoop && slider.direction !== "prev") {
                        slideString = reverse ? 0 : (slider.count + 1) * dimension;
                    } else {
                        slideString = reverse ? (slider.count - 1 - target + slider.cloneOffset) * dimension : (target + slider.cloneOffset) * dimension;
                    }
                    slider.setProps(slideString, "", slider.vars.animationSpeed);
                    if (slider.transitions) {
                        if (!slider.vars.animationLoop || !slider.atEnd) {
                            slider.animating = false;
                            slider.currentSlide = slider.animatingTo;
                        }
                        // Unbind previous transitionEnd events and re-bind new transitionEnd event
                        slider.container.unbind("webkitTransitionEnd transitionend");
                        slider.container.bind("webkitTransitionEnd transitionend", function() {
                            clearTimeout(slider.ensureAnimationEnd);
                            slider.wrapup(dimension);
                        });
                        // Insurance for the ever-so-fickle transitionEnd event
                        clearTimeout(slider.ensureAnimationEnd);
                        slider.ensureAnimationEnd = setTimeout(function() {
                            slider.wrapup(dimension);
                        }, slider.vars.animationSpeed + 100);
                    } else {
                        slider.container.animate(slider.args, slider.vars.animationSpeed, slider.vars.easing, function() {
                            slider.wrapup(dimension);
                        });
                    }
                } else {
                    // FADE:
                    if (!touch) {
                        slider.slides.eq(slider.currentSlide).css({
                            zIndex: 1
                        }).animate({
                            opacity: 0
                        }, slider.vars.animationSpeed, slider.vars.easing);
                        slider.slides.eq(target).css({
                            zIndex: 2
                        }).animate({
                            opacity: 1
                        }, slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);
                    } else {
                        slider.slides.eq(slider.currentSlide).css({
                            opacity: 0,
                            zIndex: 1
                        });
                        slider.slides.eq(target).css({
                            opacity: 1,
                            zIndex: 2
                        });
                        slider.wrapup(dimension);
                    }
                }
                // SMOOTH HEIGHT:
                if (slider.vars.smoothHeight) {
                    methods.smoothHeight(slider.vars.animationSpeed);
                }
            }
        };
        slider.wrapup = function(dimension) {
            // SLIDE:
            if (!fade && !carousel) {
                if (slider.currentSlide === 0 && slider.animatingTo === slider.last && slider.vars.animationLoop) {
                    slider.setProps(dimension, "jumpEnd");
                } else if (slider.currentSlide === slider.last && slider.animatingTo === 0 && slider.vars.animationLoop) {
                    slider.setProps(dimension, "jumpStart");
                }
            }
            slider.animating = false;
            slider.currentSlide = slider.animatingTo;
            // API: after() animation Callback
            slider.vars.after(slider);
        };
        // SLIDESHOW:
        slider.animateSlides = function() {
            if (!slider.animating && focused) {
                slider.flexAnimate(slider.getTarget("next"));
            }
        };
        // SLIDESHOW:
        slider.pause = function() {
            clearInterval(slider.animatedSlides);
            slider.animatedSlides = null;
            slider.playing = false;
            // PAUSEPLAY:
            if (slider.vars.pausePlay) {
                methods.pausePlay.update("play");
            }
            // SYNC:
            if (slider.syncExists) {
                methods.sync("pause");
            }
        };
        // SLIDESHOW:
        slider.play = function() {
            if (slider.playing) {
                clearInterval(slider.animatedSlides);
            }
            slider.animatedSlides = slider.animatedSlides || setInterval(slider.animateSlides, slider.vars.slideshowSpeed);
            slider.started = slider.playing = true;
            // PAUSEPLAY:
            if (slider.vars.pausePlay) {
                methods.pausePlay.update("pause");
            }
            // SYNC:
            if (slider.syncExists) {
                methods.sync("play");
            }
        };
        // STOP:
        slider.stop = function() {
            slider.pause();
            slider.stopped = true;
        };
        slider.canAdvance = function(target, fromNav) {
            // ASNAV:
            var last = asNav ? slider.pagingCount - 1 : slider.last;
            return fromNav ? true : asNav && slider.currentItem === slider.count - 1 && target === 0 && slider.direction === "prev" ? true : asNav && slider.currentItem === 0 && target === slider.pagingCount - 1 && slider.direction !== "next" ? false : target === slider.currentSlide && !asNav ? false : slider.vars.animationLoop ? true : slider.atEnd && slider.currentSlide === 0 && target === last && slider.direction !== "next" ? false : slider.atEnd && slider.currentSlide === last && target === 0 && slider.direction === "next" ? false : true;
        };
        slider.getTarget = function(dir) {
            slider.direction = dir;
            if (dir === "next") {
                return slider.currentSlide === slider.last ? 0 : slider.currentSlide + 1;
            } else {
                return slider.currentSlide === 0 ? slider.last : slider.currentSlide - 1;
            }
        };
        // SLIDE:
        slider.setProps = function(pos, special, dur) {
            var target = function() {
                var posCheck = pos ? pos : (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo, posCalc = function() {
                    if (carousel) {
                        return special === "setTouch" ? pos : reverse && slider.animatingTo === slider.last ? 0 : reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : slider.animatingTo === slider.last ? slider.limit : posCheck;
                    } else {
                        switch (special) {
                          case "setTotal":
                            return reverse ? (slider.count - 1 - slider.currentSlide + slider.cloneOffset) * pos : (slider.currentSlide + slider.cloneOffset) * pos;

                          case "setTouch":
                            return reverse ? pos : pos;

                          case "jumpEnd":
                            return reverse ? pos : slider.count * pos;

                          case "jumpStart":
                            return reverse ? slider.count * pos : pos;

                          default:
                            return pos;
                        }
                    }
                }();
                return posCalc * -1 + "px";
            }();
            if (slider.transitions) {
                target = vertical ? "translate3d(0," + target + ",0)" : "translate3d(" + target + ",0,0)";
                dur = dur !== undefined ? dur / 1e3 + "s" : "0s";
                slider.container.css("-" + slider.pfx + "-transition-duration", dur);
                slider.container.css("transition-duration", dur);
            }
            slider.args[slider.prop] = target;
            if (slider.transitions || dur === undefined) {
                slider.container.css(slider.args);
            }
            slider.container.css("transform", target);
        };
        slider.setup = function(type) {
            // SLIDE:
            if (!fade) {
                var sliderOffset, arr;
                if (type === "init") {
                    slider.viewport = $('<div class="' + namespace + 'viewport"></div>').css({
                        overflow: "hidden",
                        position: "relative"
                    }).appendTo(slider).append(slider.container);
                    // INFINITE LOOP:
                    slider.cloneCount = 0;
                    slider.cloneOffset = 0;
                    // REVERSE:
                    if (reverse) {
                        arr = $.makeArray(slider.slides).reverse();
                        slider.slides = $(arr);
                        slider.container.empty().append(slider.slides);
                    }
                }
                // INFINITE LOOP && !CAROUSEL:
                if (slider.vars.animationLoop && !carousel) {
                    slider.cloneCount = 2;
                    slider.cloneOffset = 1;
                    // clear out old clones
                    if (type !== "init") {
                        slider.container.find(".clone").remove();
                    }
                    slider.container.append(methods.uniqueID(slider.slides.first().clone().addClass("clone")).attr("aria-hidden", "true")).prepend(methods.uniqueID(slider.slides.last().clone().addClass("clone")).attr("aria-hidden", "true"));
                }
                slider.newSlides = $(slider.vars.selector, slider);
                sliderOffset = reverse ? slider.count - 1 - slider.currentSlide + slider.cloneOffset : slider.currentSlide + slider.cloneOffset;
                // VERTICAL:
                if (vertical && !carousel) {
                    slider.container.height((slider.count + slider.cloneCount) * 200 + "%").css("position", "absolute").width("100%");
                    setTimeout(function() {
                        slider.newSlides.css({
                            display: "block"
                        });
                        slider.doMath();
                        slider.viewport.height(slider.h);
                        slider.setProps(sliderOffset * slider.h, "init");
                    }, type === "init" ? 100 : 0);
                } else {
                    slider.container.width((slider.count + slider.cloneCount) * 200 + "%");
                    slider.setProps(sliderOffset * slider.computedW, "init");
                    setTimeout(function() {
                        slider.doMath();
                        slider.newSlides.css({
                            width: slider.computedW,
                            marginRight: slider.computedM,
                            float: "left",
                            display: "block"
                        });
                        // SMOOTH HEIGHT:
                        if (slider.vars.smoothHeight) {
                            methods.smoothHeight();
                        }
                    }, type === "init" ? 100 : 0);
                }
            } else {
                // FADE:
                slider.slides.css({
                    width: "100%",
                    float: "left",
                    marginRight: "-100%",
                    position: "relative"
                });
                if (type === "init") {
                    if (!touch) {
                        //slider.slides.eq(slider.currentSlide).fadeIn(slider.vars.animationSpeed, slider.vars.easing);
                        if (slider.vars.fadeFirstSlide == false) {
                            slider.slides.css({
                                opacity: 0,
                                display: "block",
                                zIndex: 1
                            }).eq(slider.currentSlide).css({
                                zIndex: 2
                            }).css({
                                opacity: 1
                            });
                        } else {
                            slider.slides.css({
                                opacity: 0,
                                display: "block",
                                zIndex: 1
                            }).eq(slider.currentSlide).css({
                                zIndex: 2
                            }).animate({
                                opacity: 1
                            }, slider.vars.animationSpeed, slider.vars.easing);
                        }
                    } else {
                        slider.slides.css({
                            opacity: 0,
                            display: "block",
                            webkitTransition: "opacity " + slider.vars.animationSpeed / 1e3 + "s ease",
                            zIndex: 1
                        }).eq(slider.currentSlide).css({
                            opacity: 1,
                            zIndex: 2
                        });
                    }
                }
                // SMOOTH HEIGHT:
                if (slider.vars.smoothHeight) {
                    methods.smoothHeight();
                }
            }
            // !CAROUSEL:
            // CANDIDATE: active slide
            if (!carousel) {
                slider.slides.removeClass(namespace + "active-slide").eq(slider.currentSlide).addClass(namespace + "active-slide");
            }
            //FlexSlider: init() Callback
            slider.vars.init(slider);
        };
        slider.doMath = function() {
            var slide = slider.slides.first(), slideMargin = slider.vars.itemMargin, minItems = slider.vars.minItems, maxItems = slider.vars.maxItems;
            slider.w = slider.viewport === undefined ? slider.width() : slider.viewport.width();
            slider.h = slide.height();
            slider.boxPadding = slide.outerWidth() - slide.width();
            // CAROUSEL:
            if (carousel) {
                slider.itemT = slider.vars.itemWidth + slideMargin;
                slider.itemM = slideMargin;
                slider.minW = minItems ? minItems * slider.itemT : slider.w;
                slider.maxW = maxItems ? maxItems * slider.itemT - slideMargin : slider.w;
                slider.itemW = slider.minW > slider.w ? (slider.w - slideMargin * (minItems - 1)) / minItems : slider.maxW < slider.w ? (slider.w - slideMargin * (maxItems - 1)) / maxItems : slider.vars.itemWidth > slider.w ? slider.w : slider.vars.itemWidth;
                slider.visible = Math.floor(slider.w / slider.itemW);
                slider.move = slider.vars.move > 0 && slider.vars.move < slider.visible ? slider.vars.move : slider.visible;
                slider.pagingCount = Math.ceil((slider.count - slider.visible) / slider.move + 1);
                slider.last = slider.pagingCount - 1;
                slider.limit = slider.pagingCount === 1 ? 0 : slider.vars.itemWidth > slider.w ? slider.itemW * (slider.count - 1) + slideMargin * (slider.count - 1) : (slider.itemW + slideMargin) * slider.count - slider.w - slideMargin;
            } else {
                slider.itemW = slider.w;
                slider.itemM = slideMargin;
                slider.pagingCount = slider.count;
                slider.last = slider.count - 1;
            }
            slider.computedW = slider.itemW - slider.boxPadding;
            slider.computedM = slider.itemM;
        };
        slider.update = function(pos, action) {
            slider.doMath();
            // update currentSlide and slider.animatingTo if necessary
            if (!carousel) {
                if (pos < slider.currentSlide) {
                    slider.currentSlide += 1;
                } else if (pos <= slider.currentSlide && pos !== 0) {
                    slider.currentSlide -= 1;
                }
                slider.animatingTo = slider.currentSlide;
            }
            // update controlNav
            if (slider.vars.controlNav && !slider.manualControls) {
                if (action === "add" && !carousel || slider.pagingCount > slider.controlNav.length) {
                    methods.controlNav.update("add");
                } else if (action === "remove" && !carousel || slider.pagingCount < slider.controlNav.length) {
                    if (carousel && slider.currentSlide > slider.last) {
                        slider.currentSlide -= 1;
                        slider.animatingTo -= 1;
                    }
                    methods.controlNav.update("remove", slider.last);
                }
            }
            // update directionNav
            if (slider.vars.directionNav) {
                methods.directionNav.update();
            }
        };
        slider.addSlide = function(obj, pos) {
            var $obj = $(obj);
            slider.count += 1;
            slider.last = slider.count - 1;
            // append new slide
            if (vertical && reverse) {
                pos !== undefined ? slider.slides.eq(slider.count - pos).after($obj) : slider.container.prepend($obj);
            } else {
                pos !== undefined ? slider.slides.eq(pos).before($obj) : slider.container.append($obj);
            }
            // update currentSlide, animatingTo, controlNav, and directionNav
            slider.update(pos, "add");
            // update slider.slides
            slider.slides = $(slider.vars.selector + ":not(.clone)", slider);
            // re-setup the slider to accomdate new slide
            slider.setup();
            //FlexSlider: added() Callback
            slider.vars.added(slider);
        };
        slider.removeSlide = function(obj) {
            var pos = isNaN(obj) ? slider.slides.index($(obj)) : obj;
            // update count
            slider.count -= 1;
            slider.last = slider.count - 1;
            // remove slide
            if (isNaN(obj)) {
                $(obj, slider.slides).remove();
            } else {
                vertical && reverse ? slider.slides.eq(slider.last).remove() : slider.slides.eq(obj).remove();
            }
            // update currentSlide, animatingTo, controlNav, and directionNav
            slider.doMath();
            slider.update(pos, "remove");
            // update slider.slides
            slider.slides = $(slider.vars.selector + ":not(.clone)", slider);
            // re-setup the slider to accomdate new slide
            slider.setup();
            // FlexSlider: removed() Callback
            slider.vars.removed(slider);
        };
        //FlexSlider: Initialize
        methods.init();
    };
    // Ensure the slider isn't focussed if the window loses focus.
    $(window).blur(function(e) {
        focused = false;
    }).focus(function(e) {
        focused = true;
    });
    //FlexSlider: Default Settings
    $.flexslider.defaults = {
        namespace: "flex-",
        //{NEW} String: Prefix string attached to the class of every element generated by the plugin
        selector: ".slides > li",
        //{NEW} Selector: Must match a simple pattern. '{container} > {slide}' -- Ignore pattern at your own peril
        animation: "fade",
        //String: Select your animation type, "fade" or "slide"
        easing: "swing",
        //{NEW} String: Determines the easing method used in jQuery transitions. jQuery easing plugin is supported!
        direction: "horizontal",
        //String: Select the sliding direction, "horizontal" or "vertical"
        reverse: false,
        //{NEW} Boolean: Reverse the animation direction
        animationLoop: true,
        //Boolean: Should the animation loop? If false, directionNav will received "disable" classes at either end
        smoothHeight: false,
        //{NEW} Boolean: Allow height of the slider to animate smoothly in horizontal mode
        startAt: 0,
        //Integer: The slide that the slider should start on. Array notation (0 = first slide)
        slideshow: true,
        //Boolean: Animate slider automatically
        slideshowSpeed: 7e3,
        //Integer: Set the speed of the slideshow cycling, in milliseconds
        animationSpeed: 600,
        //Integer: Set the speed of animations, in milliseconds
        initDelay: 0,
        //{NEW} Integer: Set an initialization delay, in milliseconds
        randomize: false,
        //Boolean: Randomize slide order
        fadeFirstSlide: true,
        //Boolean: Fade in the first slide when animation type is "fade"
        thumbCaptions: false,
        //Boolean: Whether or not to put captions on thumbnails when using the "thumbnails" controlNav.
        // Usability features
        pauseOnAction: true,
        //Boolean: Pause the slideshow when interacting with control elements, highly recommended.
        pauseOnHover: false,
        //Boolean: Pause the slideshow when hovering over slider, then resume when no longer hovering
        pauseInvisible: true,
        //{NEW} Boolean: Pause the slideshow when tab is invisible, resume when visible. Provides better UX, lower CPU usage.
        useCSS: true,
        //{NEW} Boolean: Slider will use CSS3 transitions if available
        touch: true,
        //{NEW} Boolean: Allow touch swipe navigation of the slider on touch-enabled devices
        video: false,
        //{NEW} Boolean: If using video in the slider, will prevent CSS3 3D Transforms to avoid graphical glitches
        // Primary Controls
        controlNav: true,
        //Boolean: Create navigation for paging control of each slide? Note: Leave true for manualControls usage
        directionNav: true,
        //Boolean: Create navigation for previous/next navigation? (true/false)
        prevText: "Previous",
        //String: Set the text for the "previous" directionNav item
        nextText: "Next",
        //String: Set the text for the "next" directionNav item
        // Secondary Navigation
        keyboard: true,
        //Boolean: Allow slider navigating via keyboard left/right keys
        multipleKeyboard: false,
        //{NEW} Boolean: Allow keyboard navigation to affect multiple sliders. Default behavior cuts out keyboard navigation with more than one slider present.
        mousewheel: false,
        //{UPDATED} Boolean: Requires jquery.mousewheel.js (https://github.com/brandonaaron/jquery-mousewheel) - Allows slider navigating via mousewheel
        pausePlay: false,
        //Boolean: Create pause/play dynamic element
        pauseText: "Pause",
        //String: Set the text for the "pause" pausePlay item
        playText: "Play",
        //String: Set the text for the "play" pausePlay item
        // Special properties
        controlsContainer: "",
        //{UPDATED} jQuery Object/Selector: Declare which container the navigation elements should be appended too. Default container is the FlexSlider element. Example use would be $(".flexslider-container"). Property is ignored if given element is not found.
        manualControls: "",
        //{UPDATED} jQuery Object/Selector: Declare custom control navigation. Examples would be $(".flex-control-nav li") or "#tabs-nav li img", etc. The number of elements in your controlNav should match the number of slides/tabs.
        customDirectionNav: "",
        //{NEW} jQuery Object/Selector: Custom prev / next button. Must be two jQuery elements. In order to make the events work they have to have the classes "prev" and "next" (plus namespace)
        sync: "",
        //{NEW} Selector: Mirror the actions performed on this slider with another slider. Use with care.
        asNavFor: "",
        //{NEW} Selector: Internal property exposed for turning the slider into a thumbnail navigation for another slider
        // Carousel Options
        itemWidth: 0,
        //{NEW} Integer: Box-model width of individual carousel items, including horizontal borders and padding.
        itemMargin: 0,
        //{NEW} Integer: Margin between carousel items.
        minItems: 1,
        //{NEW} Integer: Minimum number of carousel items that should be visible. Items will resize fluidly when below this.
        maxItems: 0,
        //{NEW} Integer: Maxmimum number of carousel items that should be visible. Items will resize fluidly when above this limit.
        move: 0,
        //{NEW} Integer: Number of carousel items that should move on animation. If 0, slider will move all visible items.
        allowOneSlide: true,
        //{NEW} Boolean: Whether or not to allow a slider comprised of a single slide
        // Callback API
        start: function() {},
        //Callback: function(slider) - Fires when the slider loads the first slide
        before: function() {},
        //Callback: function(slider) - Fires asynchronously with each slider animation
        after: function() {},
        //Callback: function(slider) - Fires after each slider animation completes
        end: function() {},
        //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)
        added: function() {},
        //{NEW} Callback: function(slider) - Fires after a slide is added
        removed: function() {},
        //{NEW} Callback: function(slider) - Fires after a slide is removed
        init: function() {}
    };
    //FlexSlider: Plugin Function
    $.fn.flexslider = function(options) {
        if (options === undefined) {
            options = {};
        }
        if (typeof options === "object") {
            return this.each(function() {
                var $this = $(this), selector = options.selector ? options.selector : ".slides > li", $slides = $this.find(selector);
                if ($slides.length === 1 && options.allowOneSlide === false || $slides.length === 0) {
                    $slides.fadeIn(400);
                    if (options.start) {
                        options.start($this);
                    }
                } else if ($this.data("flexslider") === undefined) {
                    new $.flexslider(this, options);
                }
            });
        } else {
            // Helper strings to quickly perform functions on the slider
            var $slider = $(this).data("flexslider");
            switch (options) {
              case "play":
                $slider.play();
                break;

              case "pause":
                $slider.pause();
                break;

              case "stop":
                $slider.stop();
                break;

              case "next":
                $slider.flexAnimate($slider.getTarget("next"), true);
                break;

              case "prev":
              case "previous":
                $slider.flexAnimate($slider.getTarget("prev"), true);
                break;

              default:
                if (typeof options === "number") {
                    $slider.flexAnimate(options, true);
                }
            }
        }
    };
})(jQuery);

(function(window, document, $, undefined) {
    "use strict";
    var H = $("html"), W = $(window), D = $(document), F = $.fancybox = function() {
        F.open.apply(this, arguments);
    }, IE = navigator.userAgent.match(/msie/i), didUpdate = null, isTouch = document.createTouch !== undefined, isQuery = function(obj) {
        return obj && obj.hasOwnProperty && obj instanceof $;
    }, isString = function(str) {
        return str && $.type(str) === "string";
    }, isPercentage = function(str) {
        return isString(str) && str.indexOf("%") > 0;
    }, isScrollable = function(el) {
        return el && !(el.style.overflow && el.style.overflow === "hidden") && (el.clientWidth && el.scrollWidth > el.clientWidth || el.clientHeight && el.scrollHeight > el.clientHeight);
    }, getScalar = function(orig, dim) {
        var value = parseInt(orig, 10) || 0;
        if (dim && isPercentage(orig)) {
            value = F.getViewport()[dim] / 100 * value;
        }
        return Math.ceil(value);
    }, getValue = function(value, dim) {
        return getScalar(value, dim) + "px";
    };
    $.extend(F, {
        // The current version of fancyBox
        version: "2.1.7",
        defaults: {
            padding: 15,
            margin: 20,
            width: 800,
            height: 600,
            minWidth: 100,
            minHeight: 100,
            maxWidth: 9999,
            maxHeight: 9999,
            pixelRatio: 1,
            // Set to 2 for retina display support
            autoSize: true,
            autoHeight: false,
            autoWidth: false,
            autoResize: true,
            autoCenter: !isTouch,
            fitToView: true,
            aspectRatio: false,
            topRatio: .5,
            leftRatio: .5,
            scrolling: "auto",
            // 'auto', 'yes' or 'no'
            wrapCSS: "",
            arrows: true,
            closeBtn: true,
            closeClick: false,
            nextClick: false,
            mouseWheel: true,
            autoPlay: false,
            playSpeed: 3e3,
            preload: 3,
            modal: false,
            loop: true,
            ajax: {
                dataType: "html",
                headers: {
                    "X-fancyBox": true
                }
            },
            iframe: {
                scrolling: "auto",
                preload: true
            },
            swf: {
                wmode: "transparent",
                allowfullscreen: "true",
                allowscriptaccess: "always"
            },
            keys: {
                next: {
                    13: "left",
                    // enter
                    34: "up",
                    // page down
                    39: "left",
                    // right arrow
                    40: "up"
                },
                prev: {
                    8: "right",
                    // backspace
                    33: "down",
                    // page up
                    37: "right",
                    // left arrow
                    38: "down"
                },
                close: [ 27 ],
                // escape key
                play: [ 32 ],
                // space - start/stop slideshow
                toggle: [ 70 ]
            },
            direction: {
                next: "left",
                prev: "right"
            },
            scrollOutside: true,
            // Override some properties
            index: 0,
            type: null,
            href: null,
            content: null,
            title: null,
            // HTML templates
            tpl: {
                wrap: '<div class="fancybox-wrap" tabIndex="-1"><div class="fancybox-skin"><div class="fancybox-outer"><div class="fancybox-inner"></div></div></div></div>',
                image: '<img class="fancybox-image" src="{href}" alt="" />',
                iframe: '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" frameborder="0" vspace="0" hspace="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen' + (IE ? ' allowtransparency="true"' : "") + "></iframe>",
                error: '<p class="fancybox-error">The requested content cannot be loaded.<br/>Please try again later.</p>',
                closeBtn: '<a title="Close" class="fancybox-item fancybox-close" href="javascript:;"></a>',
                next: '<a title="Next" class="fancybox-nav fancybox-next" href="javascript:;"><span></span></a>',
                prev: '<a title="Previous" class="fancybox-nav fancybox-prev" href="javascript:;"><span></span></a>',
                loading: '<div id="fancybox-loading"><div></div></div>'
            },
            // Properties for each animation type
            // Opening fancyBox
            openEffect: "fade",
            // 'elastic', 'fade' or 'none'
            openSpeed: 250,
            openEasing: "swing",
            openOpacity: true,
            openMethod: "zoomIn",
            // Closing fancyBox
            closeEffect: "fade",
            // 'elastic', 'fade' or 'none'
            closeSpeed: 250,
            closeEasing: "swing",
            closeOpacity: true,
            closeMethod: "zoomOut",
            // Changing next gallery item
            nextEffect: "elastic",
            // 'elastic', 'fade' or 'none'
            nextSpeed: 250,
            nextEasing: "swing",
            nextMethod: "changeIn",
            // Changing previous gallery item
            prevEffect: "elastic",
            // 'elastic', 'fade' or 'none'
            prevSpeed: 250,
            prevEasing: "swing",
            prevMethod: "changeOut",
            // Enable default helpers
            helpers: {
                overlay: true,
                title: true
            },
            // Callbacks
            onCancel: $.noop,
            // If canceling
            beforeLoad: $.noop,
            // Before loading
            afterLoad: $.noop,
            // After loading
            beforeShow: $.noop,
            // Before changing in current item
            afterShow: $.noop,
            // After opening
            beforeChange: $.noop,
            // Before changing gallery item
            beforeClose: $.noop,
            // Before closing
            afterClose: $.noop
        },
        //Current state
        group: {},
        // Selected group
        opts: {},
        // Group options
        previous: null,
        // Previous element
        coming: null,
        // Element being loaded
        current: null,
        // Currently loaded element
        isActive: false,
        // Is activated
        isOpen: false,
        // Is currently open
        isOpened: false,
        // Have been fully opened at least once
        wrap: null,
        skin: null,
        outer: null,
        inner: null,
        player: {
            timer: null,
            isActive: false
        },
        // Loaders
        ajaxLoad: null,
        imgPreload: null,
        // Some collections
        transitions: {},
        helpers: {},
        /*
		 *	Static methods
		 */
        open: function(group, opts) {
            if (!group) {
                return;
            }
            if (!$.isPlainObject(opts)) {
                opts = {};
            }
            // Close if already active
            if (false === F.close(true)) {
                return;
            }
            // Normalize group
            if (!$.isArray(group)) {
                group = isQuery(group) ? $(group).get() : [ group ];
            }
            // Recheck if the type of each element is `object` and set content type (image, ajax, etc)
            $.each(group, function(i, element) {
                var obj = {}, href, title, content, type, rez, hrefParts, selector;
                if ($.type(element) === "object") {
                    // Check if is DOM element
                    if (element.nodeType) {
                        element = $(element);
                    }
                    if (isQuery(element)) {
                        obj = {
                            href: element.data("fancybox-href") || element.attr("href"),
                            title: $("<div/>").text(element.data("fancybox-title") || element.attr("title") || "").html(),
                            isDom: true,
                            element: element
                        };
                        if ($.metadata) {
                            $.extend(true, obj, element.metadata());
                        }
                    } else {
                        obj = element;
                    }
                }
                href = opts.href || obj.href || (isString(element) ? element : null);
                title = opts.title !== undefined ? opts.title : obj.title || "";
                content = opts.content || obj.content;
                type = content ? "html" : opts.type || obj.type;
                if (!type && obj.isDom) {
                    type = element.data("fancybox-type");
                    if (!type) {
                        rez = element.prop("class").match(/fancybox\.(\w+)/);
                        type = rez ? rez[1] : null;
                    }
                }
                if (isString(href)) {
                    // Try to guess the content type
                    if (!type) {
                        if (F.isImage(href)) {
                            type = "image";
                        } else if (F.isSWF(href)) {
                            type = "swf";
                        } else if (href.charAt(0) === "#") {
                            type = "inline";
                        } else if (isString(element)) {
                            type = "html";
                            content = element;
                        }
                    }
                    // Split url into two pieces with source url and content selector, e.g,
                    // "/mypage.html #my_id" will load "/mypage.html" and display element having id "my_id"
                    if (type === "ajax") {
                        hrefParts = href.split(/\s+/, 2);
                        href = hrefParts.shift();
                        selector = hrefParts.shift();
                    }
                }
                if (!content) {
                    if (type === "inline") {
                        if (href) {
                            content = $(isString(href) ? href.replace(/.*(?=#[^\s]+$)/, "") : href);
                        } else if (obj.isDom) {
                            content = element;
                        }
                    } else if (type === "html") {
                        content = href;
                    } else if (!type && !href && obj.isDom) {
                        type = "inline";
                        content = element;
                    }
                }
                $.extend(obj, {
                    href: href,
                    type: type,
                    content: content,
                    title: title,
                    selector: selector
                });
                group[i] = obj;
            });
            // Extend the defaults
            F.opts = $.extend(true, {}, F.defaults, opts);
            // All options are merged recursive except keys
            if (opts.keys !== undefined) {
                F.opts.keys = opts.keys ? $.extend({}, F.defaults.keys, opts.keys) : false;
            }
            F.group = group;
            return F._start(F.opts.index);
        },
        // Cancel image loading or abort ajax request
        cancel: function() {
            var coming = F.coming;
            if (coming && false === F.trigger("onCancel")) {
                return;
            }
            F.hideLoading();
            if (!coming) {
                return;
            }
            if (F.ajaxLoad) {
                F.ajaxLoad.abort();
            }
            F.ajaxLoad = null;
            if (F.imgPreload) {
                F.imgPreload.onload = F.imgPreload.onerror = null;
            }
            if (coming.wrap) {
                coming.wrap.stop(true, true).trigger("onReset").remove();
            }
            F.coming = null;
            // If the first item has been canceled, then clear everything
            if (!F.current) {
                F._afterZoomOut(coming);
            }
        },
        // Start closing animation if is open; remove immediately if opening/closing
        close: function(event) {
            F.cancel();
            if (false === F.trigger("beforeClose")) {
                return;
            }
            F.unbindEvents();
            if (!F.isActive) {
                return;
            }
            if (!F.isOpen || event === true) {
                $(".fancybox-wrap").stop(true).trigger("onReset").remove();
                F._afterZoomOut();
            } else {
                F.isOpen = F.isOpened = false;
                F.isClosing = true;
                $(".fancybox-item, .fancybox-nav").remove();
                F.wrap.stop(true, true).removeClass("fancybox-opened");
                F.transitions[F.current.closeMethod]();
            }
        },
        // Manage slideshow:
        //   $.fancybox.play(); - toggle slideshow
        //   $.fancybox.play( true ); - start
        //   $.fancybox.play( false ); - stop
        play: function(action) {
            var clear = function() {
                clearTimeout(F.player.timer);
            }, set = function() {
                clear();
                if (F.current && F.player.isActive) {
                    F.player.timer = setTimeout(F.next, F.current.playSpeed);
                }
            }, stop = function() {
                clear();
                D.unbind(".player");
                F.player.isActive = false;
                F.trigger("onPlayEnd");
            }, start = function() {
                if (F.current && (F.current.loop || F.current.index < F.group.length - 1)) {
                    F.player.isActive = true;
                    D.bind({
                        "onCancel.player beforeClose.player": stop,
                        "onUpdate.player": set,
                        "beforeLoad.player": clear
                    });
                    set();
                    F.trigger("onPlayStart");
                }
            };
            if (action === true || !F.player.isActive && action !== false) {
                start();
            } else {
                stop();
            }
        },
        // Navigate to next gallery item
        next: function(direction) {
            var current = F.current;
            if (current) {
                if (!isString(direction)) {
                    direction = current.direction.next;
                }
                F.jumpto(current.index + 1, direction, "next");
            }
        },
        // Navigate to previous gallery item
        prev: function(direction) {
            var current = F.current;
            if (current) {
                if (!isString(direction)) {
                    direction = current.direction.prev;
                }
                F.jumpto(current.index - 1, direction, "prev");
            }
        },
        // Navigate to gallery item by index
        jumpto: function(index, direction, router) {
            var current = F.current;
            if (!current) {
                return;
            }
            index = getScalar(index);
            F.direction = direction || current.direction[index >= current.index ? "next" : "prev"];
            F.router = router || "jumpto";
            if (current.loop) {
                if (index < 0) {
                    index = current.group.length + index % current.group.length;
                }
                index = index % current.group.length;
            }
            if (current.group[index] !== undefined) {
                F.cancel();
                F._start(index);
            }
        },
        // Center inside viewport and toggle position type to fixed or absolute if needed
        reposition: function(e, onlyAbsolute) {
            var current = F.current, wrap = current ? current.wrap : null, pos;
            if (wrap) {
                pos = F._getPosition(onlyAbsolute);
                if (e && e.type === "scroll") {
                    delete pos.position;
                    wrap.stop(true, true).animate(pos, 200);
                } else {
                    wrap.css(pos);
                    current.pos = $.extend({}, current.dim, pos);
                }
            }
        },
        update: function(e) {
            var type = e && e.originalEvent && e.originalEvent.type, anyway = !type || type === "orientationchange";
            if (anyway) {
                clearTimeout(didUpdate);
                didUpdate = null;
            }
            if (!F.isOpen || didUpdate) {
                return;
            }
            didUpdate = setTimeout(function() {
                var current = F.current;
                if (!current || F.isClosing) {
                    return;
                }
                F.wrap.removeClass("fancybox-tmp");
                if (anyway || type === "load" || type === "resize" && current.autoResize) {
                    F._setDimension();
                }
                if (!(type === "scroll" && current.canShrink)) {
                    F.reposition(e);
                }
                F.trigger("onUpdate");
                didUpdate = null;
            }, anyway && !isTouch ? 0 : 300);
        },
        // Shrink content to fit inside viewport or restore if resized
        toggle: function(action) {
            if (F.isOpen) {
                F.current.fitToView = $.type(action) === "boolean" ? action : !F.current.fitToView;
                // Help browser to restore document dimensions
                if (isTouch) {
                    F.wrap.removeAttr("style").addClass("fancybox-tmp");
                    F.trigger("onUpdate");
                }
                F.update();
            }
        },
        hideLoading: function() {
            D.unbind(".loading");
            $("#fancybox-loading").remove();
        },
        showLoading: function() {
            var el, viewport;
            F.hideLoading();
            el = $(F.opts.tpl.loading).click(F.cancel).appendTo("body");
            // If user will press the escape-button, the request will be canceled
            D.bind("keydown.loading", function(e) {
                if ((e.which || e.keyCode) === 27) {
                    e.preventDefault();
                    F.cancel();
                }
            });
            if (!F.defaults.fixed) {
                viewport = F.getViewport();
                el.css({
                    position: "absolute",
                    top: viewport.h * .5 + viewport.y,
                    left: viewport.w * .5 + viewport.x
                });
            }
            F.trigger("onLoading");
        },
        getViewport: function() {
            var locked = F.current && F.current.locked || false, rez = {
                x: W.scrollLeft(),
                y: W.scrollTop()
            };
            if (locked && locked.length) {
                rez.w = locked[0].clientWidth;
                rez.h = locked[0].clientHeight;
            } else {
                // See http://bugs.jquery.com/ticket/6724
                rez.w = isTouch && window.innerWidth ? window.innerWidth : W.width();
                rez.h = isTouch && window.innerHeight ? window.innerHeight : W.height();
            }
            return rez;
        },
        // Unbind the keyboard / clicking actions
        unbindEvents: function() {
            if (F.wrap && isQuery(F.wrap)) {
                F.wrap.unbind(".fb");
            }
            D.unbind(".fb");
            W.unbind(".fb");
        },
        bindEvents: function() {
            var current = F.current, keys;
            if (!current) {
                return;
            }
            // Changing document height on iOS devices triggers a 'resize' event,
            // that can change document height... repeating infinitely
            W.bind("orientationchange.fb" + (isTouch ? "" : " resize.fb") + (current.autoCenter && !current.locked ? " scroll.fb" : ""), F.update);
            keys = current.keys;
            if (keys) {
                D.bind("keydown.fb", function(e) {
                    var code = e.which || e.keyCode, target = e.target || e.srcElement;
                    // Skip esc key if loading, because showLoading will cancel preloading
                    if (code === 27 && F.coming) {
                        return false;
                    }
                    // Ignore key combinations and key events within form elements
                    if (!e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey && !(target && (target.type || $(target).is("[contenteditable]")))) {
                        $.each(keys, function(i, val) {
                            if (current.group.length > 1 && val[code] !== undefined) {
                                F[i](val[code]);
                                e.preventDefault();
                                return false;
                            }
                            if ($.inArray(code, val) > -1) {
                                F[i]();
                                e.preventDefault();
                                return false;
                            }
                        });
                    }
                });
            }
            if ($.fn.mousewheel && current.mouseWheel) {
                F.wrap.bind("mousewheel.fb", function(e, delta, deltaX, deltaY) {
                    var target = e.target || null, parent = $(target), canScroll = false;
                    while (parent.length) {
                        if (canScroll || parent.is(".fancybox-skin") || parent.is(".fancybox-wrap")) {
                            break;
                        }
                        canScroll = isScrollable(parent[0]);
                        parent = $(parent).parent();
                    }
                    if (delta !== 0 && !canScroll) {
                        if (F.group.length > 1 && !current.canShrink) {
                            if (deltaY > 0 || deltaX > 0) {
                                F.prev(deltaY > 0 ? "down" : "left");
                            } else if (deltaY < 0 || deltaX < 0) {
                                F.next(deltaY < 0 ? "up" : "right");
                            }
                            e.preventDefault();
                        }
                    }
                });
            }
        },
        trigger: function(event, o) {
            var ret, obj = o || F.coming || F.current;
            if (obj) {
                if ($.isFunction(obj[event])) {
                    ret = obj[event].apply(obj, Array.prototype.slice.call(arguments, 1));
                }
                if (ret === false) {
                    return false;
                }
                if (obj.helpers) {
                    $.each(obj.helpers, function(helper, opts) {
                        if (opts && F.helpers[helper] && $.isFunction(F.helpers[helper][event])) {
                            F.helpers[helper][event]($.extend(true, {}, F.helpers[helper].defaults, opts), obj);
                        }
                    });
                }
            }
            D.trigger(event);
        },
        isImage: function(str) {
            return isString(str) && str.match(/(^data:image\/.*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg)((\?|#).*)?$)/i);
        },
        isSWF: function(str) {
            return isString(str) && str.match(/\.(swf)((\?|#).*)?$/i);
        },
        _start: function(index) {
            var coming = {}, obj, href, type, margin, padding;
            index = getScalar(index);
            obj = F.group[index] || null;
            if (!obj) {
                return false;
            }
            coming = $.extend(true, {}, F.opts, obj);
            // Convert margin and padding properties to array - top, right, bottom, left
            margin = coming.margin;
            padding = coming.padding;
            if ($.type(margin) === "number") {
                coming.margin = [ margin, margin, margin, margin ];
            }
            if ($.type(padding) === "number") {
                coming.padding = [ padding, padding, padding, padding ];
            }
            // 'modal' propery is just a shortcut
            if (coming.modal) {
                $.extend(true, coming, {
                    closeBtn: false,
                    closeClick: false,
                    nextClick: false,
                    arrows: false,
                    mouseWheel: false,
                    keys: null,
                    helpers: {
                        overlay: {
                            closeClick: false
                        }
                    }
                });
            }
            // 'autoSize' property is a shortcut, too
            if (coming.autoSize) {
                coming.autoWidth = coming.autoHeight = true;
            }
            if (coming.width === "auto") {
                coming.autoWidth = true;
            }
            if (coming.height === "auto") {
                coming.autoHeight = true;
            }
            /*
			 * Add reference to the group, so it`s possible to access from callbacks, example:
			 * afterLoad : function() {
			 *     this.title = 'Image ' + (this.index + 1) + ' of ' + this.group.length + (this.title ? ' - ' + this.title : '');
			 * }
			 */
            coming.group = F.group;
            coming.index = index;
            // Give a chance for callback or helpers to update coming item (type, title, etc)
            F.coming = coming;
            if (false === F.trigger("beforeLoad")) {
                F.coming = null;
                return;
            }
            type = coming.type;
            href = coming.href;
            if (!type) {
                F.coming = null;
                //If we can not determine content type then drop silently or display next/prev item if looping through gallery
                if (F.current && F.router && F.router !== "jumpto") {
                    F.current.index = index;
                    return F[F.router](F.direction);
                }
                return false;
            }
            F.isActive = true;
            if (type === "image" || type === "swf") {
                coming.autoHeight = coming.autoWidth = false;
                coming.scrolling = "visible";
            }
            if (type === "image") {
                coming.aspectRatio = true;
            }
            if (type === "iframe" && isTouch) {
                coming.scrolling = "scroll";
            }
            // Build the neccessary markup
            coming.wrap = $(coming.tpl.wrap).addClass("fancybox-" + (isTouch ? "mobile" : "desktop") + " fancybox-type-" + type + " fancybox-tmp " + coming.wrapCSS).appendTo(coming.parent || "body");
            $.extend(coming, {
                skin: $(".fancybox-skin", coming.wrap),
                outer: $(".fancybox-outer", coming.wrap),
                inner: $(".fancybox-inner", coming.wrap)
            });
            $.each([ "Top", "Right", "Bottom", "Left" ], function(i, v) {
                coming.skin.css("padding" + v, getValue(coming.padding[i]));
            });
            F.trigger("onReady");
            // Check before try to load; 'inline' and 'html' types need content, others - href
            if (type === "inline" || type === "html") {
                if (!coming.content || !coming.content.length) {
                    return F._error("content");
                }
            } else if (!href) {
                return F._error("href");
            }
            if (type === "image") {
                F._loadImage();
            } else if (type === "ajax") {
                F._loadAjax();
            } else if (type === "iframe") {
                F._loadIframe();
            } else {
                F._afterLoad();
            }
        },
        _error: function(type) {
            $.extend(F.coming, {
                type: "html",
                autoWidth: true,
                autoHeight: true,
                minWidth: 0,
                minHeight: 0,
                scrolling: "no",
                hasError: type,
                content: F.coming.tpl.error
            });
            F._afterLoad();
        },
        _loadImage: function() {
            // Reset preload image so it is later possible to check "complete" property
            var img = F.imgPreload = new Image();
            img.onload = function() {
                this.onload = this.onerror = null;
                F.coming.width = this.width / F.opts.pixelRatio;
                F.coming.height = this.height / F.opts.pixelRatio;
                F._afterLoad();
            };
            img.onerror = function() {
                this.onload = this.onerror = null;
                F._error("image");
            };
            img.src = F.coming.href;
            if (img.complete !== true) {
                F.showLoading();
            }
        },
        _loadAjax: function() {
            var coming = F.coming;
            F.showLoading();
            F.ajaxLoad = $.ajax($.extend({}, coming.ajax, {
                url: coming.href,
                error: function(jqXHR, textStatus) {
                    if (F.coming && textStatus !== "abort") {
                        F._error("ajax", jqXHR);
                    } else {
                        F.hideLoading();
                    }
                },
                success: function(data, textStatus) {
                    if (textStatus === "success") {
                        coming.content = data;
                        F._afterLoad();
                    }
                }
            }));
        },
        _loadIframe: function() {
            var coming = F.coming, iframe = $(coming.tpl.iframe.replace(/\{rnd\}/g, new Date().getTime())).attr("scrolling", isTouch ? "auto" : coming.iframe.scrolling).attr("src", coming.href);
            // This helps IE
            $(coming.wrap).bind("onReset", function() {
                try {
                    $(this).find("iframe").hide().attr("src", "//about:blank").end().empty();
                } catch (e) {}
            });
            if (coming.iframe.preload) {
                F.showLoading();
                iframe.one("load", function() {
                    $(this).data("ready", 1);
                    // iOS will lose scrolling if we resize
                    if (!isTouch) {
                        $(this).bind("load.fb", F.update);
                    }
                    // Without this trick:
                    //   - iframe won't scroll on iOS devices
                    //   - IE7 sometimes displays empty iframe
                    $(this).parents(".fancybox-wrap").width("100%").removeClass("fancybox-tmp").show();
                    F._afterLoad();
                });
            }
            coming.content = iframe.appendTo(coming.inner);
            if (!coming.iframe.preload) {
                F._afterLoad();
            }
        },
        _preloadImages: function() {
            var group = F.group, current = F.current, len = group.length, cnt = current.preload ? Math.min(current.preload, len - 1) : 0, item, i;
            for (i = 1; i <= cnt; i += 1) {
                item = group[(current.index + i) % len];
                if (item.type === "image" && item.href) {
                    new Image().src = item.href;
                }
            }
        },
        _afterLoad: function() {
            var coming = F.coming, previous = F.current, placeholder = "fancybox-placeholder", current, content, type, scrolling, href, embed;
            F.hideLoading();
            if (!coming || F.isActive === false) {
                return;
            }
            if (false === F.trigger("afterLoad", coming, previous)) {
                coming.wrap.stop(true).trigger("onReset").remove();
                F.coming = null;
                return;
            }
            if (previous) {
                F.trigger("beforeChange", previous);
                previous.wrap.stop(true).removeClass("fancybox-opened").find(".fancybox-item, .fancybox-nav").remove();
            }
            F.unbindEvents();
            current = coming;
            content = coming.content;
            type = coming.type;
            scrolling = coming.scrolling;
            $.extend(F, {
                wrap: current.wrap,
                skin: current.skin,
                outer: current.outer,
                inner: current.inner,
                current: current,
                previous: previous
            });
            href = current.href;
            switch (type) {
              case "inline":
              case "ajax":
              case "html":
                if (current.selector) {
                    content = $("<div>").html(content).find(current.selector);
                } else if (isQuery(content)) {
                    if (!content.data(placeholder)) {
                        content.data(placeholder, $('<div class="' + placeholder + '"></div>').insertAfter(content).hide());
                    }
                    content = content.show().detach();
                    current.wrap.bind("onReset", function() {
                        if ($(this).find(content).length) {
                            content.hide().replaceAll(content.data(placeholder)).data(placeholder, false);
                        }
                    });
                }
                break;

              case "image":
                content = current.tpl.image.replace(/\{href\}/g, href);
                break;

              case "swf":
                content = '<object id="fancybox-swf" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="100%" height="100%"><param name="movie" value="' + href + '"></param>';
                embed = "";
                $.each(current.swf, function(name, val) {
                    content += '<param name="' + name + '" value="' + val + '"></param>';
                    embed += " " + name + '="' + val + '"';
                });
                content += '<embed src="' + href + '" type="application/x-shockwave-flash" width="100%" height="100%"' + embed + "></embed></object>";
                break;
            }
            if (!(isQuery(content) && content.parent().is(current.inner))) {
                current.inner.append(content);
            }
            // Give a chance for helpers or callbacks to update elements
            F.trigger("beforeShow");
            // Set scrolling before calculating dimensions
            current.inner.css("overflow", scrolling === "yes" ? "scroll" : scrolling === "no" ? "hidden" : scrolling);
            // Set initial dimensions and start position
            F._setDimension();
            F.reposition();
            F.isOpen = false;
            F.coming = null;
            F.bindEvents();
            if (!F.isOpened) {
                $(".fancybox-wrap").not(current.wrap).stop(true).trigger("onReset").remove();
            } else if (previous.prevMethod) {
                F.transitions[previous.prevMethod]();
            }
            F.transitions[F.isOpened ? current.nextMethod : current.openMethod]();
            F._preloadImages();
        },
        _setDimension: function() {
            var viewport = F.getViewport(), steps = 0, canShrink = false, canExpand = false, wrap = F.wrap, skin = F.skin, inner = F.inner, current = F.current, width = current.width, height = current.height, minWidth = current.minWidth, minHeight = current.minHeight, maxWidth = current.maxWidth, maxHeight = current.maxHeight, scrolling = current.scrolling, scrollOut = current.scrollOutside ? current.scrollbarWidth : 0, margin = current.margin, wMargin = getScalar(margin[1] + margin[3]), hMargin = getScalar(margin[0] + margin[2]), wPadding, hPadding, wSpace, hSpace, origWidth, origHeight, origMaxWidth, origMaxHeight, ratio, width_, height_, maxWidth_, maxHeight_, iframe, body;
            // Reset dimensions so we could re-check actual size
            wrap.add(skin).add(inner).width("auto").height("auto").removeClass("fancybox-tmp");
            wPadding = getScalar(skin.outerWidth(true) - skin.width());
            hPadding = getScalar(skin.outerHeight(true) - skin.height());
            // Any space between content and viewport (margin, padding, border, title)
            wSpace = wMargin + wPadding;
            hSpace = hMargin + hPadding;
            origWidth = isPercentage(width) ? (viewport.w - wSpace) * getScalar(width) / 100 : width;
            origHeight = isPercentage(height) ? (viewport.h - hSpace) * getScalar(height) / 100 : height;
            if (current.type === "iframe") {
                iframe = current.content;
                if (current.autoHeight && iframe && iframe.data("ready") === 1) {
                    try {
                        if (iframe[0].contentWindow.document.location) {
                            inner.width(origWidth).height(9999);
                            body = iframe.contents().find("body");
                            if (scrollOut) {
                                body.css("overflow-x", "hidden");
                            }
                            origHeight = body.outerHeight(true);
                        }
                    } catch (e) {}
                }
            } else if (current.autoWidth || current.autoHeight) {
                inner.addClass("fancybox-tmp");
                // Set width or height in case we need to calculate only one dimension
                if (!current.autoWidth) {
                    inner.width(origWidth);
                }
                if (!current.autoHeight) {
                    inner.height(origHeight);
                }
                if (current.autoWidth) {
                    origWidth = inner.width();
                }
                if (current.autoHeight) {
                    origHeight = inner.height();
                }
                inner.removeClass("fancybox-tmp");
            }
            width = getScalar(origWidth);
            height = getScalar(origHeight);
            ratio = origWidth / origHeight;
            // Calculations for the content
            minWidth = getScalar(isPercentage(minWidth) ? getScalar(minWidth, "w") - wSpace : minWidth);
            maxWidth = getScalar(isPercentage(maxWidth) ? getScalar(maxWidth, "w") - wSpace : maxWidth);
            minHeight = getScalar(isPercentage(minHeight) ? getScalar(minHeight, "h") - hSpace : minHeight);
            maxHeight = getScalar(isPercentage(maxHeight) ? getScalar(maxHeight, "h") - hSpace : maxHeight);
            // These will be used to determine if wrap can fit in the viewport
            origMaxWidth = maxWidth;
            origMaxHeight = maxHeight;
            if (current.fitToView) {
                maxWidth = Math.min(viewport.w - wSpace, maxWidth);
                maxHeight = Math.min(viewport.h - hSpace, maxHeight);
            }
            maxWidth_ = viewport.w - wMargin;
            maxHeight_ = viewport.h - hMargin;
            if (current.aspectRatio) {
                if (width > maxWidth) {
                    width = maxWidth;
                    height = getScalar(width / ratio);
                }
                if (height > maxHeight) {
                    height = maxHeight;
                    width = getScalar(height * ratio);
                }
                if (width < minWidth) {
                    width = minWidth;
                    height = getScalar(width / ratio);
                }
                if (height < minHeight) {
                    height = minHeight;
                    width = getScalar(height * ratio);
                }
            } else {
                width = Math.max(minWidth, Math.min(width, maxWidth));
                if (current.autoHeight && current.type !== "iframe") {
                    inner.width(width);
                    height = inner.height();
                }
                height = Math.max(minHeight, Math.min(height, maxHeight));
            }
            // Try to fit inside viewport (including the title)
            if (current.fitToView) {
                inner.width(width).height(height);
                wrap.width(width + wPadding);
                // Real wrap dimensions
                width_ = wrap.width();
                height_ = wrap.height();
                if (current.aspectRatio) {
                    while ((width_ > maxWidth_ || height_ > maxHeight_) && width > minWidth && height > minHeight) {
                        if (steps++ > 19) {
                            break;
                        }
                        height = Math.max(minHeight, Math.min(maxHeight, height - 10));
                        width = getScalar(height * ratio);
                        if (width < minWidth) {
                            width = minWidth;
                            height = getScalar(width / ratio);
                        }
                        if (width > maxWidth) {
                            width = maxWidth;
                            height = getScalar(width / ratio);
                        }
                        inner.width(width).height(height);
                        wrap.width(width + wPadding);
                        width_ = wrap.width();
                        height_ = wrap.height();
                    }
                } else {
                    width = Math.max(minWidth, Math.min(width, width - (width_ - maxWidth_)));
                    height = Math.max(minHeight, Math.min(height, height - (height_ - maxHeight_)));
                }
            }
            if (scrollOut && scrolling === "auto" && height < origHeight && width + wPadding + scrollOut < maxWidth_) {
                width += scrollOut;
            }
            inner.width(width).height(height);
            wrap.width(width + wPadding);
            width_ = wrap.width();
            height_ = wrap.height();
            canShrink = (width_ > maxWidth_ || height_ > maxHeight_) && width > minWidth && height > minHeight;
            canExpand = current.aspectRatio ? width < origMaxWidth && height < origMaxHeight && width < origWidth && height < origHeight : (width < origMaxWidth || height < origMaxHeight) && (width < origWidth || height < origHeight);
            $.extend(current, {
                dim: {
                    width: getValue(width_),
                    height: getValue(height_)
                },
                origWidth: origWidth,
                origHeight: origHeight,
                canShrink: canShrink,
                canExpand: canExpand,
                wPadding: wPadding,
                hPadding: hPadding,
                wrapSpace: height_ - skin.outerHeight(true),
                skinSpace: skin.height() - height
            });
            if (!iframe && current.autoHeight && height > minHeight && height < maxHeight && !canExpand) {
                inner.height("auto");
            }
        },
        _getPosition: function(onlyAbsolute) {
            var current = F.current, viewport = F.getViewport(), margin = current.margin, width = F.wrap.width() + margin[1] + margin[3], height = F.wrap.height() + margin[0] + margin[2], rez = {
                position: "absolute",
                top: margin[0],
                left: margin[3]
            };
            if (current.autoCenter && current.fixed && !onlyAbsolute && height <= viewport.h && width <= viewport.w) {
                rez.position = "fixed";
            } else if (!current.locked) {
                rez.top += viewport.y;
                rez.left += viewport.x;
            }
            rez.top = getValue(Math.max(rez.top, rez.top + (viewport.h - height) * current.topRatio));
            rez.left = getValue(Math.max(rez.left, rez.left + (viewport.w - width) * current.leftRatio));
            return rez;
        },
        _afterZoomIn: function() {
            var current = F.current;
            if (!current) {
                return;
            }
            F.isOpen = F.isOpened = true;
            F.wrap.css("overflow", "visible").addClass("fancybox-opened").hide().show(0);
            F.update();
            // Assign a click event
            if (current.closeClick || current.nextClick && F.group.length > 1) {
                F.inner.css("cursor", "pointer").bind("click.fb", function(e) {
                    if (!$(e.target).is("a") && !$(e.target).parent().is("a")) {
                        e.preventDefault();
                        F[current.closeClick ? "close" : "next"]();
                    }
                });
            }
            // Create a close button
            if (current.closeBtn) {
                $(current.tpl.closeBtn).appendTo(F.skin).bind("click.fb", function(e) {
                    e.preventDefault();
                    F.close();
                });
            }
            // Create navigation arrows
            if (current.arrows && F.group.length > 1) {
                if (current.loop || current.index > 0) {
                    $(current.tpl.prev).appendTo(F.outer).bind("click.fb", F.prev);
                }
                if (current.loop || current.index < F.group.length - 1) {
                    $(current.tpl.next).appendTo(F.outer).bind("click.fb", F.next);
                }
            }
            F.trigger("afterShow");
            // Stop the slideshow if this is the last item
            if (!current.loop && current.index === current.group.length - 1) {
                F.play(false);
            } else if (F.opts.autoPlay && !F.player.isActive) {
                F.opts.autoPlay = false;
                F.play(true);
            }
        },
        _afterZoomOut: function(obj) {
            obj = obj || F.current;
            $(".fancybox-wrap").trigger("onReset").remove();
            $.extend(F, {
                group: {},
                opts: {},
                router: false,
                current: null,
                isActive: false,
                isOpened: false,
                isOpen: false,
                isClosing: false,
                wrap: null,
                skin: null,
                outer: null,
                inner: null
            });
            F.trigger("afterClose", obj);
        }
    });
    /*
	 *	Default transitions
	 */
    F.transitions = {
        getOrigPosition: function() {
            var current = F.current, element = current.element, orig = current.orig, pos = {}, width = 50, height = 50, hPadding = current.hPadding, wPadding = current.wPadding, viewport = F.getViewport();
            if (!orig && current.isDom && element.is(":visible")) {
                orig = element.find("img:first");
                if (!orig.length) {
                    orig = element;
                }
            }
            if (isQuery(orig)) {
                pos = orig.offset();
                if (orig.is("img")) {
                    width = orig.outerWidth();
                    height = orig.outerHeight();
                }
            } else {
                pos.top = viewport.y + (viewport.h - height) * current.topRatio;
                pos.left = viewport.x + (viewport.w - width) * current.leftRatio;
            }
            if (F.wrap.css("position") === "fixed" || current.locked) {
                pos.top -= viewport.y;
                pos.left -= viewport.x;
            }
            pos = {
                top: getValue(pos.top - hPadding * current.topRatio),
                left: getValue(pos.left - wPadding * current.leftRatio),
                width: getValue(width + wPadding),
                height: getValue(height + hPadding)
            };
            return pos;
        },
        step: function(now, fx) {
            var ratio, padding, value, prop = fx.prop, current = F.current, wrapSpace = current.wrapSpace, skinSpace = current.skinSpace;
            if (prop === "width" || prop === "height") {
                ratio = fx.end === fx.start ? 1 : (now - fx.start) / (fx.end - fx.start);
                if (F.isClosing) {
                    ratio = 1 - ratio;
                }
                padding = prop === "width" ? current.wPadding : current.hPadding;
                value = now - padding;
                F.skin[prop](getScalar(prop === "width" ? value : value - wrapSpace * ratio));
                F.inner[prop](getScalar(prop === "width" ? value : value - wrapSpace * ratio - skinSpace * ratio));
            }
        },
        zoomIn: function() {
            var current = F.current, startPos = current.pos, effect = current.openEffect, elastic = effect === "elastic", endPos = $.extend({
                opacity: 1
            }, startPos);
            // Remove "position" property that breaks older IE
            delete endPos.position;
            if (elastic) {
                startPos = this.getOrigPosition();
                if (current.openOpacity) {
                    startPos.opacity = .1;
                }
            } else if (effect === "fade") {
                startPos.opacity = .1;
            }
            F.wrap.css(startPos).animate(endPos, {
                duration: effect === "none" ? 0 : current.openSpeed,
                easing: current.openEasing,
                step: elastic ? this.step : null,
                complete: F._afterZoomIn
            });
        },
        zoomOut: function() {
            var current = F.current, effect = current.closeEffect, elastic = effect === "elastic", endPos = {
                opacity: .1
            };
            if (elastic) {
                endPos = this.getOrigPosition();
                if (current.closeOpacity) {
                    endPos.opacity = .1;
                }
            }
            F.wrap.animate(endPos, {
                duration: effect === "none" ? 0 : current.closeSpeed,
                easing: current.closeEasing,
                step: elastic ? this.step : null,
                complete: F._afterZoomOut
            });
        },
        changeIn: function() {
            var current = F.current, effect = current.nextEffect, startPos = current.pos, endPos = {
                opacity: 1
            }, direction = F.direction, distance = 200, field;
            startPos.opacity = .1;
            if (effect === "elastic") {
                field = direction === "down" || direction === "up" ? "top" : "left";
                if (direction === "down" || direction === "right") {
                    startPos[field] = getValue(getScalar(startPos[field]) - distance);
                    endPos[field] = "+=" + distance + "px";
                } else {
                    startPos[field] = getValue(getScalar(startPos[field]) + distance);
                    endPos[field] = "-=" + distance + "px";
                }
            }
            // Workaround for http://bugs.jquery.com/ticket/12273
            if (effect === "none") {
                F._afterZoomIn();
            } else {
                F.wrap.css(startPos).animate(endPos, {
                    duration: current.nextSpeed,
                    easing: current.nextEasing,
                    complete: F._afterZoomIn
                });
            }
        },
        changeOut: function() {
            var previous = F.previous, effect = previous.prevEffect, endPos = {
                opacity: .1
            }, direction = F.direction, distance = 200;
            if (effect === "elastic") {
                endPos[direction === "down" || direction === "up" ? "top" : "left"] = (direction === "up" || direction === "left" ? "-" : "+") + "=" + distance + "px";
            }
            previous.wrap.animate(endPos, {
                duration: effect === "none" ? 0 : previous.prevSpeed,
                easing: previous.prevEasing,
                complete: function() {
                    $(this).trigger("onReset").remove();
                }
            });
        }
    };
    /*
	 *	Overlay helper
	 */
    F.helpers.overlay = {
        defaults: {
            closeClick: true,
            // if true, fancyBox will be closed when user clicks on the overlay
            speedOut: 200,
            // duration of fadeOut animation
            showEarly: true,
            // indicates if should be opened immediately or wait until the content is ready
            css: {},
            // custom CSS properties
            locked: !isTouch,
            // if true, the content will be locked into overlay
            fixed: true
        },
        overlay: null,
        // current handle
        fixed: false,
        // indicates if the overlay has position "fixed"
        el: $("html"),
        // element that contains "the lock"
        // Public methods
        create: function(opts) {
            var parent;
            opts = $.extend({}, this.defaults, opts);
            if (this.overlay) {
                this.close();
            }
            parent = F.coming ? F.coming.parent : opts.parent;
            this.overlay = $('<div class="fancybox-overlay"></div>').appendTo(parent && parent.length ? parent : "body");
            this.fixed = false;
            if (opts.fixed && F.defaults.fixed) {
                this.overlay.addClass("fancybox-overlay-fixed");
                this.fixed = true;
            }
        },
        open: function(opts) {
            var that = this;
            opts = $.extend({}, this.defaults, opts);
            if (this.overlay) {
                this.overlay.unbind(".overlay").width("auto").height("auto");
            } else {
                this.create(opts);
            }
            if (!this.fixed) {
                W.bind("resize.overlay", $.proxy(this.update, this));
                this.update();
            }
            if (opts.closeClick) {
                this.overlay.bind("click.overlay", function(e) {
                    if ($(e.target).hasClass("fancybox-overlay")) {
                        if (F.isActive) {
                            F.close();
                        } else {
                            that.close();
                        }
                        return false;
                    }
                });
            }
            this.overlay.css(opts.css).show();
        },
        close: function() {
            W.unbind("resize.overlay");
            if (this.el.hasClass("fancybox-lock")) {
                $(".fancybox-margin").removeClass("fancybox-margin");
                this.el.removeClass("fancybox-lock");
                W.scrollTop(this.scrollV).scrollLeft(this.scrollH);
            }
            $(".fancybox-overlay").remove().hide();
            $.extend(this, {
                overlay: null,
                fixed: false
            });
        },
        // Private, callbacks
        update: function() {
            var width = "100%", offsetWidth;
            // Reset width/height so it will not mess
            this.overlay.width(width).height("100%");
            // jQuery does not return reliable result for IE
            if (IE) {
                offsetWidth = Math.max(document.documentElement.offsetWidth, document.body.offsetWidth);
                if (D.width() > offsetWidth) {
                    width = D.width();
                }
            } else if (D.width() > W.width()) {
                width = D.width();
            }
            this.overlay.width(width).height(D.height());
        },
        // This is where we can manipulate DOM, because later it would cause iframes to reload
        onReady: function(opts, obj) {
            var overlay = this.overlay;
            $(".fancybox-overlay").stop(true, true);
            if (!overlay) {
                this.create(opts);
            }
            if (opts.locked && this.fixed && obj.fixed) {
                obj.locked = this.overlay.append(obj.wrap);
                obj.fixed = false;
            }
            if (opts.showEarly === true) {
                this.beforeShow.apply(this, arguments);
            }
        },
        beforeShow: function(opts, obj) {
            if (obj.locked && !this.el.hasClass("fancybox-lock")) {
                if (this.fixPosition !== false) {
                    $("*:not(object)").filter(function() {
                        return $(this).css("position") === "fixed" && !$(this).hasClass("fancybox-overlay") && !$(this).hasClass("fancybox-wrap");
                    }).addClass("fancybox-margin");
                }
                this.el.addClass("fancybox-margin");
                this.scrollV = W.scrollTop();
                this.scrollH = W.scrollLeft();
                this.el.addClass("fancybox-lock");
                W.scrollTop(this.scrollV).scrollLeft(this.scrollH);
            }
            this.open(opts);
        },
        onUpdate: function() {
            if (!this.fixed) {
                this.update();
            }
        },
        afterClose: function(opts) {
            // Remove overlay if exists and fancyBox is not opening
            // (e.g., it is not being open using afterClose callback)
            if (this.overlay && !F.coming) {
                this.overlay.fadeOut(opts.speedOut, $.proxy(this.close, this));
            }
        }
    };
    /*
	 *	Title helper
	 */
    F.helpers.title = {
        defaults: {
            type: "float",
            // 'float', 'inside', 'outside' or 'over',
            position: "bottom"
        },
        beforeShow: function(opts) {
            var current = F.current, text = current.title, type = opts.type, title, target;
            if ($.isFunction(text)) {
                text = text.call(current.element, current);
            }
            if (!isString(text) || $.trim(text) === "") {
                return;
            }
            title = $('<div class="fancybox-title fancybox-title-' + type + '-wrap">' + text + "</div>");
            switch (type) {
              case "inside":
                target = F.skin;
                break;

              case "outside":
                target = F.wrap;
                break;

              case "over":
                target = F.inner;
                break;

              default:
                // 'float'
                target = F.skin;
                title.appendTo("body");
                if (IE) {
                    title.width(title.width());
                }
                title.wrapInner('<span class="child"></span>');
                //Increase bottom margin so this title will also fit into viewport
                F.current.margin[2] += Math.abs(getScalar(title.css("margin-bottom")));
                break;
            }
            title[opts.position === "top" ? "prependTo" : "appendTo"](target);
        }
    };
    // jQuery plugin initialization
    $.fn.fancybox = function(options) {
        var index, that = $(this), selector = this.selector || "", run = function(e) {
            var what = $(this).blur(), idx = index, relType, relVal;
            if (!(e.ctrlKey || e.altKey || e.shiftKey || e.metaKey) && !what.is(".fancybox-wrap")) {
                relType = options.groupAttr || "data-fancybox-group";
                relVal = what.attr(relType);
                if (!relVal) {
                    relType = "rel";
                    relVal = what.get(0)[relType];
                }
                if (relVal && relVal !== "" && relVal !== "nofollow") {
                    what = selector.length ? $(selector) : that;
                    what = what.filter("[" + relType + '="' + relVal + '"]');
                    idx = what.index(this);
                }
                options.index = idx;
                // Stop an event from bubbling if everything is fine
                if (F.open(what, options) !== false) {
                    e.preventDefault();
                }
            }
        };
        options = options || {};
        index = options.index || 0;
        if (!selector || options.live === false) {
            that.unbind("click.fb-start").bind("click.fb-start", run);
        } else {
            D.undelegate(selector, "click.fb-start").delegate(selector + ":not('.fancybox-item, .fancybox-nav')", "click.fb-start", run);
        }
        this.filter("[data-fancybox-start=1]").trigger("click");
        return this;
    };
    // Tests that need a body at doc ready
    D.ready(function() {
        var w1, w2;
        if ($.scrollbarWidth === undefined) {
            // http://benalman.com/projects/jquery-misc-plugins/#scrollbarwidth
            $.scrollbarWidth = function() {
                var parent = $('<div style="width:50px;height:50px;overflow:auto"><div/></div>').appendTo("body"), child = parent.children(), width = child.innerWidth() - child.height(99).innerWidth();
                parent.remove();
                return width;
            };
        }
        if ($.support.fixedPosition === undefined) {
            $.support.fixedPosition = function() {
                var elem = $('<div style="position:fixed;top:20px;"></div>').appendTo("body"), fixed = elem[0].offsetTop === 20 || elem[0].offsetTop === 15;
                elem.remove();
                return fixed;
            }();
        }
        $.extend(F.defaults, {
            scrollbarWidth: $.scrollbarWidth(),
            fixed: $.support.fixedPosition,
            parent: $("body")
        });
        //Get real width of page scroll-bar
        w1 = $(window).width();
        H.addClass("fancybox-lock-test");
        w2 = $(window).width();
        H.removeClass("fancybox-lock-test");
        $("<style type='text/css'>.fancybox-margin{margin-right:" + (w2 - w1) + "px;}</style>").appendTo("head");
    });
})(window, document, jQuery);

// global _:false, moment:false, Modernizr:false
var AIB = window.AIB || {};

(function($) {
    "use strict";
    AIB.breakpoints = {
        smallMax: 767,
        mediumMin: 768,
        mediumMax: 1023,
        largeMin: 1024,
        largeMax: 1199,
        hugeMin: 1200
    };
    AIB.init = function() {
        AIB.nav.init();
        AIB.homepage.init();
        AIB.blogIndex.init();
        AIB.blogArticle.init();
        AIB.landing.init();
        AIB.initForms.init();
        AIB.initSubjects.init();
        AIB.initGeneral.init();
        AIB.footer.init();
    };
    // Nav function
    AIB.nav = {
        mobileNavInit: false,
        desktopNavInit: false,
        resetToMobileDone: false,
        resetToDesktopDone: false,
        init: function() {
            // Do not run if there's no nav
            if (!$("nav").length) {
                return false;
            }
            var self = this;
            var viewport = AIB.utils.viewport();
            self.initNavSearch();
            self.initSectionNav();
            if (viewport.width < AIB.breakpoints.largeMin) {
                self.initMobileNav();
            } else {
                self.initNav();
            }
            $(window).on("orientationchange", function() {
                self.initResetNav();
            });
            window.addEventListener("resize", AIB.utils.debounce(self.initResetNav, 250));
        },
        initNav: function() {
            var self = this;
            var $overlayTargets = $("body, nav");
            var $header = $("header");
            var $body = $("body");
            $(".js-toggle-nav-child, .js-toggle-search").on("click", function(event) {
                event.preventDefault();
                var $this = $(this);
                var targetID = $this.attr("href");
                var $target = $(targetID);
                var $parent = $this.parent();
                if ($parent.hasClass("child--open")) {
                    $parent.removeClass("child--open");
                    $target.fadeOut();
                    $overlayTargets.removeClass("nav--open");
                    $("#nav-overlay").attr("data-id", "");
                } else {
                    $(".child--open").removeClass("child--open");
                    $parent.addClass("child--open");
                    $(".nav__child").not($target).fadeOut();
                    $target.fadeIn();
                    $overlayTargets.addClass("nav--open");
                    $("#nav-overlay").attr("data-id", targetID);
                }
                self.toggleNavOverlay();
            });
            $(".js-close-nav").on("click", function() {
                var $this = $(this);
                var $target = $this.parent().prev(".js-toggle-nav-child");
                if ($target.length <= 0) {
                    $target = $this.parent().prev(".js-toggle-search");
                }
                $target.trigger("click");
            });
            $("#nav-overlay").on("click", function() {
                var targetID = $(this).attr("data-id");
                $(targetID + " .js-close-nav").trigger("click");
            });
            // Sticky nav for desktop
            var subNavTop;
            if ($(".section-nav").length > 0) {
                subNavTop = $(".section-nav").offset().top - 100;
            }
            var navTop = $header.outerHeight();
            self.updateSticky($body, navTop, subNavTop);
            $(window).on("scroll", function() {
                self.updateSticky($body, navTop, subNavTop);
            });
            self.desktopNavInit = true;
        },
        initMobileNav: function() {
            var self = this;
            $(window).unbind("scroll");
            $(".js-toggle-nav").on("click", function(event) {
                if (event) {
                    event.preventDefault();
                }
                $(this).toggleClass("nav--open");
                $("body").toggleClass("nav--open");
                self.toggleNavOverlay();
                $("nav > .row").slideToggle();
            });
            $("#nav-overlay").on("click", function(event) {
                if (event) {
                    event.preventDefault();
                }
                $(".js-toggle-nav").trigger("click");
            });
            $(".js-toggle-nav-child").on("click", function(event) {
                event.preventDefault();
                var $this = $(this);
                var targetID = $this.attr("href");
                var $target = $(targetID);
                var $parent = $this.parent().parent("ul");
                $parent.addClass("child--open");
                // 300 is required to be consistant with css transitino setting.
                $target.animate({
                    left: "0"
                }, 300, "linear");
            });
            $(".js-toggle-nav-parent").on("click", function(event) {
                event.preventDefault();
                var $this = $(this);
                var $target = $this.parent().parent("ul");
                var $parent = $($this.attr("href")).parent("ul");
                $parent.removeClass("child--open");
                // 300 is required to be consistant with css transitino setting.
                $target.animate({
                    left: "100%"
                }, 300, "linear");
            });
            self.mobileNavInit = true;
        },
        toggleNavOverlay: function() {
            var $overlay = $("#nav-overlay");
            if (!$("body").hasClass(".nav--open")) {
                $overlay.show();
            } else {
                $overlay.hide();
            }
        },
        initSectionNav: function() {
            $(".section-nav a").on("click", function(event) {
                event.preventDefault();
                AIB.utils.scrollToElement($($(this).attr("href")));
            });
        },
        initNavSearch: function() {
            var $targetForm = $("#nav__search--hidden form");
            $("#nav__search--js").on("submit", function(event) {
                event.preventDefault();
                $targetForm.find("#str").val($(this).find('input[name="search"]').val());
                $targetForm.submit();
                return false;
            });
        },
        updateSticky: function($target, navPos, subNavTop) {
            if ($(window).scrollTop() >= navPos && !$target.hasClass("is-sticky")) {
                $target.addClass("is-sticky");
            } else if ($(window).scrollTop() < navPos && $target.hasClass("is-sticky")) {
                $target.removeClass("is-sticky");
            }
            if ($(".section-nav").length > 0) {
                if ($(window).scrollTop() >= subNavTop) {
                    $target.addClass("is-sticky is-sticky-section");
                } else if ($(window).scrollTop() < subNavTop && $target.hasClass("is-sticky-section")) {
                    $target.removeClass("is-sticky-section");
                }
            }
        },
        initResetNav: function() {
            var viewport = AIB.utils.viewport();
            var resetDesktop = AIB.nav.mobileNavInit && viewport.width > AIB.breakpoints.mediumMin ? true : false;
            var resetMobile = AIB.nav.desktopNavInit && viewport.width <= AIB.breakpoints.mediumMin ? true : false;
            if (resetDesktop || resetMobile) {
                if (resetMobile && !AIB.nav.resetToMobileDone) {
                    // Change to mobile nav
                    AIB.nav.resetToMobileNav();
                    AIB.nav.resetToMobileDone = true;
                } else if (resetDesktop && !AIB.nav.resetToDesktopDone) {
                    // Change to desktop nav
                    AIB.nav.resetToDesktopNav();
                    AIB.nav.resetToDesktopDone = true;
                }
            }
        },
        resetToDesktopNav: function() {
            var self = this;
            $(".nav--open").removeClass("nav--open");
            self.toggleNavOverlay();
            $("nav > .row, .nav__child").attr("style", "");
            $(".child--open").removeClass("child--open");
            $(".js-toggle-nav-parent, .js-toggle-nav-child, .js-toggle-nav, .js-toggle-search, .js-close-nav, #nav-overlay").off("click");
            self.initNav();
        },
        resetToMobileNav: function() {
            var self = this;
            $(".child--open").removeClass("child--open");
            $(".nav--open").removeClass("nav--open");
            self.toggleNavOverlay();
            $(".js-toggle-nav-child, .js-toggle-nav-parent .js-toggle-search, .js-close-nav, .js-toggle-nav, #nav-overlay").off("click");
            self.initMobileNav();
        }
    };
    // homepage
    AIB.homepage = {
        init: function() {
            // Do not run if it is not homepage
            if (!$(".homepage").length) {
                return false;
            }
            var self = this;
            self.initSlider();
            self.requestCallForm();
        },
        initSlider: function() {
            $(".js-slider--home").flexslider({
                animation: "slide",
                directionNav: false,
                smoothHeight: true
            });
        },
        requestCallForm: function() {
            $(".form--request-call").on("submit", function(event) {
                event.preventDefault();
                var $this = $(this);
                var $initial = $this.find(".initial");
                var $secondary = $this.find(".secondary");
                if ($secondary.is(":hidden")) {
                    console.log("submit the first time!");
                    $initial.fadeOut(function() {
                        $secondary.fadeIn();
                    });
                } else {
                    console.log("submit the second time!");
                }
                return false;
            });
        }
    };
    // blog index
    AIB.blogIndex = {
        init: function() {
            // Do not run if it is not blog index page
            if (!$(".blog-index").length) {
                return false;
            }
            var self = this;
            self.formatDate();
            this.formatDescription();
            self.initCategoryDropdown();
            self.updateBreadcrumb();
        },
        formatDate: function() {
            if (!$(".item__date").length) {
                return false;
            }
            $(".item__date").each(function(index, item) {
                var date = $(item).text().trim();
                var d = new Date(date.replace(/(\d+)\/(\d+)\/(\d+)\s(.+)/, "$3/$2/$1 $4")).toString();
                if (d !== "Invalid Date") {
                    var rst = d.split(" ");
                    $(item).html(rst[2] + " " + rst[1]);
                } else {
                    $(item).remove();
                }
            });
        },
        formatDescription: function() {
            $("div.item__description>p:first-child").each(function(index, item) {
                var list = $(item).text().split(" ");
                if (list.length > 30) {
                    list.splice(30);
                    list.push("...");
                }
                $(item).html(list.join(" "));
            });
        },
        initCategoryDropdown: function() {
            $(".js-category-toggle").on("click", function(event) {
                event.preventDefault();
                $(".js-category-dropdown").slideToggle();
            });
        },
        updateBreadcrumb: function() {
            var catText;
            $(".js-category-dropdown li a").each(function() {
                var $this = $(this);
                var url = $this.attr("href");
                if (window.location.pathname.indexOf(url) >= 0) {
                    catText = $this.html();
                    var $new = $('<li itemscope itemtype="http://data-vocabulary.org/Breadcrumb"><a itemprop="url" href="/blog/" title="Blog" class="centricBreadcrumbsLink">' + '<span itemprop="title">Blog</span></a><span class="centricBreadcrumbsSeparator">&nbsp;&gt;&nbsp;</span></li>');
                    $new.insertBefore("#centricBreadcrumbs li:last");
                    $(".centricBreadcrumbsCurrent").html(catText);
                }
            });
        }
    };
    // blog article
    AIB.blogArticle = {
        init: function() {
            // Do not run if it is not blog article page
            if (!$(".blog-article").length) {
                return false;
            }
            var self = this;
            self.formatDate();
            AIB.blogIndex.initCategoryDropdown();
            self.updateBreadcrumb();
        },
        formatDate: function() {
            if (!$(".article__date").length) {
                return false;
            }
            var $item = $(".article__date");
            var date = $item.text().trim();
            var d = new Date(date.replace(/(\d+)\/(\d+)\/(\d+)\s(.+)/, "$3/$2/$1 $4")).toString();
            if (d !== "Invalid Date") {
                var rst = d.split(" ");
                $item.html(rst[2] + " " + rst[1]);
            } else {
                $item.remove();
            }
        },
        updateBreadcrumb: function() {
            var catText;
            $(".js-category-dropdown li a").each(function() {
                var $this = $(this);
                var url = $this.attr("href");
                if (window.location.pathname.indexOf(url) >= 0) {
                    catText = $this.html();
                    var $new = $('<li itemscope itemtype="http://data-vocabulary.org/Breadcrumb"><a itemprop="url" href="' + url + '" title="' + catText + '" class="centricBreadcrumbsLink"><span itemprop="title">' + catText + '</span></a><span class="centricBreadcrumbsSeparator">&nbsp;&gt;&nbsp;</span></li>');
                    $new.insertBefore("#centricBreadcrumbs li:last");
                }
            });
        }
    };
    // landing template
    AIB.landing = {
        init: function() {
            // Do not run if it is not landing page
            if (!$(".landing").length) {
                return false;
            }
            var self = this;
            self.initTestimonialSlider();
        },
        initTestimonialSlider: function() {
            $(".js-slider--testimonial").flexslider({
                animation: "slide",
                smoothHeight: true
            });
        }
    };
    // form functions
    AIB.initForms = {
        init: function() {
            var self = this;
            self.initEnquiryForm();
            self.initBlogPreview();
            self.updateSelectFields();
            self.formValidation();
        },
        initEnquiryForm: function() {
            var self = this;
            $(".js-enquiry-form").on("click", function(event) {
                if (event) {
                    event.preventDefault();
                }
                self.initFancyboxForm();
            });
        },
        initFancyboxForm: function(url) {
            if (!url) {
                url = "#enquiry__form";
            }
            $.fancybox({
                href: url,
                padding: [ 20, 20, 20, 20 ],
                closeClick: false,
                autoSize: true,
                autoCenter: true,
                helper: {
                    overlay: {
                        locked: true
                    }
                },
                afterLoad: function(current) {
                    // bind any script or function that needs to be working on the form
                    if (!$(".homepage").length) {
                        AIB.homepage.requestCallForm();
                    }
                },
                afterClose: function() {}
            });
        },
        initBlogPreview: function() {
            var $form = $("#blog-form");
            if ($form.length) {
                var $previewBtn = $form.find("#submit_Preview");
                var $submitBtn = $form.find("#submit_Submit");
                var $submission = $form.find('input[name="submission_id"]');
                var actionURL = "/blog/blog-article.jsp";
                var previewValue = "t";
                if ($submission.length > 0 && $submission.val() > 0) {
                    actionURL = actionURL + "?s_id=" + $submission.val();
                }
                $previewBtn.on("click", function(e) {
                    $form.attr("action", actionURL);
                    $form.attr("target", "_blank");
                    $form.find('input[name="f_preview"]').val(previewValue);
                });
                $submitBtn.on("click", function(e) {
                    $form.attr("action", "");
                    $form.attr("target", "");
                    $form.find('input[name="f_preview"]').val("f");
                });
            }
        },
        updateSelectFields: function() {
            $("select").each(function() {
                var $this = $(this);
                var $parent = $this.parent();
                if (!$parent.hasClass("select") && !$this.prop("multiple")) {
                    $this.wrap('<div class="select"></div>');
                }
            });
        },
        formValidation: function() {
            var self = this;
            $('.datefield input[type="text"]').on("focus", function() {
                $(".datefield a img").trigger("click");
            });
            $("#blog-form").on("submit", function(event) {
                event.preventDefault();
                var $this = $(this);
                var valid = true;
                var $title = $("#input_title");
                var titleErr = "input_title_err";
                var $description = $("#input_description");
                var descriptionErr = "input_description_err";
                var $content = $("#content");
                var contentErr = "content_err";
                var $datePublished = $("#date_publishedDate");
                var datePublishedErr = "date_publishedDate_err";
                var $primaryCategory = $("#primary_category");
                var primaryCategoryErr = "primary_category_err";
                var $blogCategory = $("#blog_category");
                var blogCategoryErr = "blog_category_err";
                var $featurePost = $('input[name="feature_post"]');
                var featurePostErr = "feature_post_err";
                if (!self.validateField($title, titleErr)) {
                    valid = false;
                }
                if (!self.validateField($description, descriptionErr)) {
                    valid = false;
                }
                if (!self.validateField($content, contentErr)) {
                    valid = false;
                }
                if (!self.validateField($datePublished, datePublishedErr)) {
                    valid = false;
                }
                if (!self.validateField($primaryCategory, primaryCategoryErr)) {
                    valid = false;
                }
                if (!self.validateField($blogCategory, blogCategoryErr)) {
                    valid = false;
                }
                if (!self.validateField($featurePost, featurePostErr)) {
                    valid = false;
                }
                console.log($this.find('input[name="f_preview"]').val());
                if (valid) {
                    if ($this.find('input[name="f_preview"]').val() === "f") {
                        // 'f' means it's actual submit. prevent double bind if it's form submit.
                        $this.unbind("submit");
                    }
                    $this[0].submit();
                }
            });
            $("#student_stories").on("submit", function(event) {
                event.preventDefault();
                var $this = $(this);
                var valid = true;
                var $title = $("#input_title");
                var titleErr = "input_title_err";
                var $description = $("#input_description");
                var descriptionErr = "input_description_err";
                if (!self.validateField($title, titleErr)) {
                    valid = false;
                }
                if (!self.validateField($description, descriptionErr)) {
                    valid = false;
                }
                if (valid) {
                    $this.unbind("submit");
                    $this[0].submit();
                }
            });
            $("#testimonials").on("submit", function(event) {
                event.preventDefault();
                var $this = $(this);
                var valid = true;
                var $name = $("#input_name");
                var nameErr = "input_name_err";
                var $title = $("#input_title");
                var titleErr = "input_title_err";
                var $quote = $("#quote");
                var quoteErr = "quote_err";
                if (!self.validateField($name, nameErr)) {
                    valid = false;
                }
                if (!self.validateField($title, titleErr)) {
                    valid = false;
                }
                if (!self.validateField($quote, quoteErr)) {
                    valid = false;
                }
                if (valid) {
                    $this.unbind("submit");
                    $this[0].submit();
                }
            });
            $("#faq_form").on("submit", function(event) {
                event.preventDefault();
                var $this = $(this);
                var valid = true;
                var $title = $("#input_title");
                var titleErr = "input_title_err";
                var $description = $("#input_description");
                var descriptionErr = "input_description_err";
                var $content = $("#content");
                var contentErr = "content_err";
                if (!self.validateField($title, titleErr)) {
                    valid = false;
                }
                if (!self.validateField($description, descriptionErr)) {
                    valid = false;
                }
                if (!self.validateField($content, contentErr)) {
                    valid = false;
                }
                if (valid) {
                    $this.unbind("submit");
                    $this[0].submit();
                }
            });
            $("#careers_form").on("submit", function(event) {
                event.preventDefault();
                var $this = $(this);
                var valid = true;
                var $title = $("#input_title");
                var titleErr = "input_title_err";
                var $description = $("#input_description");
                var descriptionErr = "input_description_err";
                var $content = $("#content");
                var contentErr = "content_err";
                var $department = $("#input_department");
                var departmentErr = "input_department_err";
                if (!self.validateField($title, titleErr)) {
                    valid = false;
                }
                if (!self.validateField($description, descriptionErr)) {
                    valid = false;
                }
                if (!self.validateField($content, contentErr)) {
                    valid = false;
                }
                if (!self.validateField($department, departmentErr)) {
                    valid = false;
                }
                if (valid) {
                    $this.unbind("submit");
                    $this[0].submit();
                }
            });
        },
        validateField: function($field, errorId, regex, msg) {
            var self = this;
            var val = $field.val();
            var valid = true;
            if (!msg) {
                msg = "This field is mandatory.";
            }
            if ($field.next(".cke").length > 0) {
                val = window.CKEDITOR.instances[$field.attr("name")].getData();
            }
            if ($field.is(":radio") || $field.is(":checkbox")) {
                var selected = false;
                $field.each(function() {
                    if ($(this).prop("checked")) {
                        selected = true;
                    }
                });
                if (!selected) {
                    val = null;
                }
            }
            if (!val || val === "" || regex && !regex.test(val)) {
                if (regex) {
                    self.showErrorMsg($field, errorId, "valid ", msg);
                } else {
                    self.showErrorMsg($field, errorId, undefined, msg);
                }
                valid = false;
            } else {
                self.hideErrorMsg(errorId, $field);
            }
            return valid;
        },
        showErrorMsg: function($field, errorId, valid, msg) {
            if (!valid) {
                valid = "";
            }
            var $error = $("#" + errorId);
            if ($error.length > 0) {
                $error.show();
            } else {
                var $target = $field.parents(".formElementContainer");
                $('<div id="' + errorId + '" class="errorMsg">' + msg + "</div>").insertAfter($target);
            }
            if ($field.is(":radio") || $field.is(":checkbox")) {
                $field.each(function() {
                    $('label[for="' + $(this).attr("id") + '"]').addClass("error");
                });
            } else {
                $field.addClass("error");
            }
        },
        hideErrorMsg: function(errorId, $field) {
            $("#" + errorId).hide();
            if ($field.is(":radio") || $field.is(":checkbox")) {
                $field.each(function() {
                    $('label[for="' + $(this).attr("id") + '"]').removeClass("error");
                });
            } else {
                $field.removeClass("error");
            }
        }
    };
    AIB.initSubjects = {
        init: function() {
            // Do not run if there is no subjects section
            if (!$(".subjects").length) {
                return false;
            }
            $(".js-expand").on("click", function(event) {
                if (event) {
                    event.preventDefault();
                }
                var $this = $(this);
                var $parent = $this.parent();
                var $target = $($this.attr("data-target"));
                if ($parent.hasClass("active")) {
                    // collapse
                    $target.slideUp(function() {
                        $parent.removeClass("active");
                    });
                } else {
                    // active
                    $target.slideDown();
                    $parent.addClass("active");
                }
            });
        }
    };
    AIB.initGeneral = {
        init: function() {
            if ($("table").length > 0) {
                $("table").each(function() {
                    var $this = $(this);
                    if (!$this.parent().hasClass("table-wrap")) {
                        $this.wrap('<div class="table-wrap"></div>');
                    }
                });
            }
        }
    };
    // footer
    AIB.footer = {
        init: function() {
            $(".back-to-top").on("click", function(event) {
                event.preventDefault();
                AIB.utils.scrollToElement();
            });
        }
    };
    // Helper utils
    AIB.utils = {
        // return viewport width / height (better cross-browser)
        viewport: function() {
            var e = window;
            var a = "inner";
            if (!("innerWidth" in window)) {
                a = "client";
                e = document.documentElement || document.body;
            }
            return {
                width: e[a + "Width"],
                height: e[a + "Height"]
            };
        },
        scrollToElement: function($target, duration) {
            var scrollTo = 0;
            if (!duration) {
                duration = 500;
            }
            if ($target) {
                scrollTo = $target.offset().top;
            }
            $("html, body").animate({
                scrollTop: scrollTo
            }, duration);
        },
        debounce: function(func, wait, immediate) {
            var timeout;
            return function() {
                var context = this;
                var args = arguments;
                var later = function() {
                    timeout = null;
                    if (!immediate) {
                        func.apply(context, args);
                    }
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) {
                    func.apply(context, args);
                }
            };
        }
    };
    AIB.init();
})(jQuery);